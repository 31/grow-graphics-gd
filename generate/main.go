package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
)

func convertType(gdType string) string {
	switch gdType {
	case "int":
		return "int64"
	case "float":
		return "float64"
	case "String":
		return "string"
	case "enum::Error":
		return "error"
	case "const uint8_t **":
		return "*[]byte"
	case "const void*", "const uint8_t*", "const uint8_t *", "PackedByteArray":
		return "[]byte"
	case "PackedStringArray":
		return "[]string"
	case "PackedInt32Array":
		return "[]int32"
	case "PackedInt64Array":
		return "[]int64"
	case "PackedFloat32Array":
		return "[]float32"
	case "PackedFloat64Array":
		return "[]float64"
	case "PackedVector2Array":
		return "[]Vector2"
	case "PackedVector3Array":
		return "[]Vector3"
	case "PackedColorArray":
		return "[]Color"
	case "StringName":
		return "string"
	case "Variant":
		return "any"
	case "float*":
		return "*float64"
	case "int32_t*":
		return "*int32"
	case "void*", "uint8_t*":
		return "[]byte"
	default:
		if strings.HasPrefix(gdType, "const") {
			gdType = strings.TrimPrefix(gdType, "const")
		}
		if strings.HasSuffix(gdType, "*") {
			return "*" + gdType[:len(gdType)-1]
		}
		if strings.HasPrefix(gdType, "enum::") {
			return strings.TrimPrefix(strings.Replace(gdType, ".", "", -1), "enum::")
		}
		if strings.HasPrefix(gdType, "bitfield::") {
			return strings.TrimPrefix(strings.Replace(gdType, ".", "", -1), "bitfield::")
		}
		return gdType
	}
}

func convertName(fnName string) string {
	fnName = strings.ToLower(fnName)

	joins := []string{}
	split := strings.Split(fnName, "_")
	for _, word := range split {
		joins = append(joins, strings.Title(word))
	}
	/*if joins[0] == "Get" {
		backup := joins
		joins = joins[1:]

		if len(joins) == 0 {
			joins = backup
		} else {
			if _, err := strconv.Atoi(joins[0]); err == nil {
				joins = backup
			}
		}
	}*/
	return strings.Join(joins, "")
}

func fixReserved(name string) string {
	switch name {
	case "type":
		return "atype"
	case "range":
		return "arange"
	case "default":
		return "def"
	case "func":
		return "fn"
	case "interface":
		return "intf"
	case "map":
		return "mapping"
	case "var":
		return "v"
	case "string":
		return "s"
	default:
		return name
	}
}

func genEnum(code io.Writer, prefix string, enum Enum) {
	name := prefix + strings.Replace(enum.Name, ".", "", -1)

	fmt.Fprintln(code)
	fmt.Fprintf(code, "type %v int64\n", name)
	if len(enum.Values) > 0 {
		fmt.Fprintln(code)
		fmt.Fprintf(code, "const (\n")
		for _, value := range enum.Values {
			n := prefix + convertName(value.Name)
			if n == name {
				n += "Default"
			}
			fmt.Fprintf(code, "\t%v %v = %v\n", n, name, value.Value)
		}
		fmt.Fprintf(code, ")\n")
	}
}

func generate() error {
	file, err := os.Open("./api.json")
	if os.IsNotExist(err) {
		req, err := http.NewRequest("GET", "https://raw.githubusercontent.com/godotengine/godot-headers/master/extension_api.json", nil)
		if err != nil {
			return err
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return err
		}

		file, err = os.Create("./api.json")
		if err != nil {
			return err
		}

		_, err = io.Copy(file, resp.Body)
		if err != nil {
			return err
		}

		file.Seek(0, 0)
		resp.Body.Close()
	}

	var spec Specification
	if err := json.NewDecoder(file).Decode(&spec); err != nil {
		return err
	}

	code, err := os.Create("./api.go")
	if err != nil {
		return err
	}

	var exceptions = map[string]bool{
		"GDScriptNativeClass": true,
		"JavaClassWrapper":    true,
		"JavaScript":          true,
	}

	fmt.Fprintln(code, `// Code generated by the generate package DO NOT EDIT`)
	fmt.Fprintln(code, `package gd`)
	fmt.Fprintln(code)
	fmt.Fprintln(code, `import "github.com/readykit/gd/gdnative"`)

	for _, enum := range spec.GlobalEnums {
		genEnum(code, "", enum)
	}

	for _, class := range spec.BuiltinClasses {
		for _, enum := range class.Enums {
			genEnum(code, class.Name, enum)
		}
	}

	for _, class := range spec.Classes {
		for _, enum := range class.Enums {
			genEnum(code, class.Name, enum)
		}

		fmt.Fprintln(code)
		fmt.Fprintf(code, "type %v gdnative.Object\n", class.Name)
		fmt.Fprintf(code, `func (%v) class() string { return "%v\000" }`+"\n", class.Name, class.Name)
		fmt.Fprintln(code)
		if class.Inherits != "" {
			fmt.Fprintf(code, `func (gdClass %v) %[2]v() %[2]v { return %[2]v(gdClass) }`+"\n", class.Name, class.Inherits)
			fmt.Fprintln(code)
		}

		var methodCount = 0
		var virtualCount = 0
		for _, method := range class.Methods {
			if !method.IsVirtual {
				methodCount++
			} else {
				virtualCount++
			}
		}

		if methodCount > 0 {
			fmt.Fprintf(code, "var method%v [%d]gdnative.Method\n", class.Name, methodCount)
		}

		if virtualCount > 0 {
			fmt.Fprintf(code, "func (gdClass %v) virtual(val any, name string) any {", class.Name)
			fmt.Fprintln(code, "\tswitch name {")
			for _, method := range class.Methods {
				if !method.IsVirtual {
					continue
				}

				result := convertType(method.ReturnValue.Type)

				fmt.Fprintln(code, "\tcase \""+method.Name+"\":")
				fmt.Fprintf(code, "\t\ti, ok := val.(interface{ %v(", convertName(method.Name))
				for i, arg := range method.Arguments {
					fmt.Fprintf(code, "%v %v", fixReserved(arg.Name), convertType(arg.Type))
					if i < len(method.Arguments)-1 {
						fmt.Fprint(code, ", ")
					}
				}
				fmt.Fprintf(code, ") %v })\n", result)
				fmt.Fprintln(code, "\t\tif ok {")
				fmt.Fprintf(code, "\t\t\treturn i.%v\n", convertName(method.Name))
				fmt.Fprintln(code, "\t\t}")
			}
			fmt.Fprintln(code, "\t}")
			fmt.Fprintln(code, "\treturn nil")
			fmt.Fprintln(code, "}")
		}

		var i int
		for _, method := range class.Methods {
			if method.IsVirtual {
				continue
			}

			result := convertType(method.ReturnValue.Type)

			fmt.Fprintf(code, "func (gdClass %v) %v(", class.Name, convertName(method.Name))
			for i, arg := range method.Arguments {
				fmt.Fprintf(code, "%v %v", fixReserved(arg.Name), convertType(arg.Type))
				if i < len(method.Arguments)-1 {
					fmt.Fprint(code, ", ")
				}
			}
			fmt.Fprintf(code, ") %v { ", result)
			if result != "" {
				fmt.Fprintf(code, "return gdnative.Return[%v](gdnative.Object(gdClass), method%v[%d]", result, class.Name, i)
			} else {
				fmt.Fprintf(code, "gdnative.Call(gdnative.Object(gdClass), method%v[%d]", class.Name, i)
			}
			for _, arg := range method.Arguments {
				fmt.Fprint(code, ", ")
				fmt.Fprintf(code, "%v", fixReserved(arg.Name))
			}
			fmt.Fprintf(code, ") }\n")
			i++
		}
	}

	fmt.Fprintln(code)
	fmt.Fprintf(code, `func init() {`)
	fmt.Fprintf(code, "\tgdnative.OnLoad(func() {")
	for _, class := range spec.Classes {
		var i int
		for _, method := range class.Methods {
			if _, ok := exceptions[class.Name]; ok {
				continue
			}

			if method.IsVirtual {
				continue
			}
			fmt.Fprintf(code, "\t\t"+`method%v[%d] = gdnative.MethodOf("%v\000", "%v\000", %v)`+"\n", class.Name, i, class.Name, method.Name, method.Hash)
			i++
		}
	}
	fmt.Fprintf(code, "\t})\n}")

	fmt.Println(len(spec.Classes))

	return nil
}

func main() {
	if err := generate(); err != nil {
		log.Fatal(err)
	}
}
