package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"strings"

	"github.com/readykit/gd/internal/packages"
)

func (db ClassDB) hasNative(gdType string) bool {
	switch gdType {
	case "int", "float", "String", "bool",
		"PackedStringArray", "PackedInt32Array", "PackedInt64Array",
		"PackedFloat32Array", "PackedFloat64Array", "PackedVector2Array",
		"PackedVector3Array", "PackedColorArray", "Variant":
		return true
	}
	return false
}

func (db ClassDB) convertType(pkg, meta string, gdType string) string {
	switch gdType {
	case "int":
		return "int64"
	case "float":
		return "float64"
	case "bool":
		return "bool"
	case "String":
		return "string"

	case "PackedStringArray":
		return "[]string"
	case "PackedInt32Array":
		return "[]int32"
	case "PackedInt64Array":
		return "[]int64"
	case "PackedFloat32Array":
		return "[]float32"
	case "PackedFloat64Array":
		return "[]float64"
	case "PackedVector2Array":
		return "[]gd.Vector2"
	case "PackedVector3Array":
		return "[]gd.Vector3"
	case "PackedColorArray":
		return "[]visual.Color"
	case "Variant":
		return "any"

	// strange C++ cases
	case "enum::Error":
		return "int64"
	case "const uint8_t **":
		return "*[]byte"
	case "const void*", "const uint8_t*", "const uint8_t *", "PackedByteArray":
		return "[]byte"
	case "float*":
		return "*float64"
	case "int32_t*":
		return "*int32"
	case "void*", "uint8_t*":
		return "[]byte"

	default:
		gdType = strings.TrimPrefix(gdType, "const")

		if strings.HasSuffix(gdType, "*") {
			return "*" + gdType[:len(gdType)-1]
		}

		gdType = strings.TrimPrefix(strings.Replace(gdType, ".", "", -1), "enum::")
		gdType = strings.TrimPrefix(strings.Replace(gdType, ".", "", -1), "bitfield::")

		if _, ok := db[gdType]; ok {
			return db.nameOf(pkg, gdType)
		}

		return strings.Replace(gdType, ".", "", -1)
	}
}

func convertName(fnName string) string {
	if fnName == "seek" {
		return "SeekTo"
	}

	fnName = strings.ToLower(fnName)

	joins := []string{}
	split := strings.Split(fnName, "_")
	for _, word := range split {
		joins = append(joins, strings.Title(word))
	}
	/*if joins[0] == "Get" {
		backup := joins
		joins = joins[1:]

		if len(joins) == 0 {
			joins = backup
		} else {
			if _, err := strconv.Atoi(joins[0]); err == nil {
				joins = backup
			}
		}
	}*/
	return strings.Join(joins, "")
}

func genEnum(pkg string, code io.Writer, prefix string, enum Enum) {
	switch {
	case
		strings.HasPrefix(prefix, "Class"),
		strings.HasPrefix(prefix, "OS"),
		strings.HasPrefix(prefix, "OpenAction"),
		strings.HasPrefix(prefix, "RenderingServer"),
		strings.HasPrefix(prefix, "RenderingDevice"):
		prefix = ""
	}

	name := prefix + strings.Replace(enum.Name, ".", "", -1)
	name = strings.TrimPrefix(name, strings.Title(path.Base(pkg)))
	name = strings.TrimPrefix(name, strings.ToUpper(path.Base(pkg)))

	fmt.Fprintln(code)
	fmt.Fprintf(code, "type %v int64\n", name)
	if len(enum.Values) > 0 {
		fmt.Fprintln(code)
		fmt.Fprintf(code, "const (\n")
		for _, value := range enum.Values {
			n := prefix + convertName(value.Name)
			if n == name {
				n += "Default"
			}

			n = strings.TrimPrefix(n, strings.Title(path.Base(pkg)))
			n = strings.TrimPrefix(n, strings.ToUpper(path.Base(pkg)))
			n = strings.Replace(n, "XR", "", -1)
			n = strings.Replace(n, "xr", "", -1)
			n = strings.Replace(n, "Xr", "", -1)

			fmt.Fprintf(code, "\t%v %v = %v\n", n, name, value.Value)
		}
		fmt.Fprintf(code, ")\n")
	}
}

type ClassDB map[string]Class

func (db ClassDB) genPackage(name string, classes []string) error {
	if err := os.MkdirAll("./"+name, 0755); err != nil {
		return err
	}

	code, err := os.Create("./" + name + "/api.go")
	if err != nil {
		return err
	}

	fmt.Fprintln(code, `// Code generated by /internal/packages/generator DO NOT EDIT`)
	fmt.Fprintln(code, `package `+path.Base(name))
	fmt.Fprintln(code)
	fmt.Fprintf(code, `import "github.com/readykit/gd"`+"\n")

	for i := range classes {
		class := db[classes[i]]

		if class.Name == strings.Title(path.Base(name)) {
			if db[class.Name].singleton {
				class.Name = "ClassSingleton"
			} else {
				class.Name = "Class"
			}
		}
		if class.Name == "StringName" {
			class.Name = "Name"
		}
		class.Name = db.nameOf(name, class.Name)

		for _, enum := range class.Enums {
			genEnum(name, code, class.Name, enum)
		}
	}

	for i := range classes {
		class := db[classes[i]]
		db.genClass(name, code, class)
	}

	return code.Close()
}

func (db ClassDB) nameOf(pkg, original string) string {
	class := db[original]
	if class.singleton {
		original += "Singleton"
	}
	name := strings.Replace(strings.Title(original), strings.Title(path.Base(pkg)), "", 1)
	name = strings.Replace(name, strings.ToUpper(path.Base(pkg)), "", 1)
	name = strings.Replace(name, "ENet", "", 1)
	name = strings.Replace(name, "WebRTC", "", 1)
	name = strings.Replace(name, "WebSocket", "", 1)
	name = strings.Replace(name, "OpenXR", "Open", 1)
	name = strings.Replace(name, "XR", "", 1)
	name = strings.Replace(name, "Xr", "", 1)
	name = strings.Replace(name, "xr", "", 1)
	name = strings.Replace(name, "RD", "", 1)
	return name
}

func (db ClassDB) genClass(pkg string, code io.Writer, class Class) {
	originalName := class.Name

	if class.Name == "StringName" {
		originalName = "Name"
		class.Name = "Name"
	}
	class.Name = db.nameOf(pkg, class.Name)
	if class.Name == "" || class.Name == "Singleton" {
		if class.singleton {
			class.Name = "ClassSingleton"
		} else {
			class.Name = "Class"
		}
	}

	if class.singleton {
		fmt.Fprintln(code)
		fmt.Fprintf(code, "var %v %v\n",
			strings.TrimSuffix(class.Name, "Singleton"), class.Name)
		fmt.Fprintln(code)
		fmt.Fprintf(code, "type %[1]v = gd.%vSingleton\n", class.Name, strings.Title(originalName))
	} else {
		fmt.Fprintln(code)
		fmt.Fprintf(code, "type %[1]v = gd.%v\n", class.Name, strings.Title(originalName))
	}
}

func generate() error {
	var spec Specification

	if err := spec.Load(); err != nil {
		return err
	}

	db, err := spec.ClassDB()
	if err != nil {
		return err
	}

	for name, pkg := range packages.List {
		if err := db.genPackage(name, pkg); err != nil {
			return err
		}
	}

	return nil
}

func main() {
	if err := generate(); err != nil {
		log.Fatal(err)
	}
}
