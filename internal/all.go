//go:build !generate

// Code generated by the generate package DO NOT EDIT
package gd

import "unsafe"
import "reflect"
import "runtime.link/mmm"
import "grow.graphics/gd/internal/callframe"

type Corner int64

type Orientation int64

type ClockDirection int64

type HorizontalAlignment int64

type VerticalAlignment int64

type InlineAlignment int64

type Key int64

type KeyModifierMask int64

type MouseButton int64

type MouseButtonMask int64

type JoyButton int64

type JoyAxis int64

type MIDIMessage int64

type Error int64

const (
	/*Methods that return [enum Error] return [constant OK] when no error occurred.
	  Since [constant OK] has value 0, and all other error constants are positive integers, it can also be used in boolean checks.
	  [b]Example:[/b]
	  [codeblock]
	  var error = method_that_returns_error()
	  if error != OK:
	      printerr("Failure!")

	  # Or, alternatively:
	  if error:
	      printerr("Still failing!")
	  [/codeblock]
	  [b]Note:[/b] Many functions do not return an error code, but will print error messages to standard output.*/
	Ok Error = 0
	/*Generic error.*/
	Failed Error = 1
	/*Unavailable error.*/
	ErrUnavailable Error = 2
	/*Unconfigured error.*/
	ErrUnconfigured Error = 3
	/*Unauthorized error.*/
	ErrUnauthorized Error = 4
	/*Parameter range error.*/
	ErrParameterRangeError Error = 5
	/*Out of memory (OOM) error.*/
	ErrOutOfMemory Error = 6
	/*File: Not found error.*/
	ErrFileNotFound Error = 7
	/*File: Bad drive error.*/
	ErrFileBadDrive Error = 8
	/*File: Bad path error.*/
	ErrFileBadPath Error = 9
	/*File: No permission error.*/
	ErrFileNoPermission Error = 10
	/*File: Already in use error.*/
	ErrFileAlreadyInUse Error = 11
	/*File: Can't open error.*/
	ErrFileCantOpen Error = 12
	/*File: Can't write error.*/
	ErrFileCantWrite Error = 13
	/*File: Can't read error.*/
	ErrFileCantRead Error = 14
	/*File: Unrecognized error.*/
	ErrFileUnrecognized Error = 15
	/*File: Corrupt error.*/
	ErrFileCorrupt Error = 16
	/*File: Missing dependencies error.*/
	ErrFileMissingDependencies Error = 17
	/*File: End of file (EOF) error.*/
	ErrFileEof Error = 18
	/*Can't open error.*/
	ErrCantOpen Error = 19
	/*Can't create error.*/
	ErrCantCreate Error = 20
	/*Query failed error.*/
	ErrQueryFailed Error = 21
	/*Already in use error.*/
	ErrAlreadyInUse Error = 22
	/*Locked error.*/
	ErrLocked Error = 23
	/*Timeout error.*/
	ErrTimeout Error = 24
	/*Can't connect error.*/
	ErrCantConnect Error = 25
	/*Can't resolve error.*/
	ErrCantResolve Error = 26
	/*Connection error.*/
	ErrConnectionError Error = 27
	/*Can't acquire resource error.*/
	ErrCantAcquireResource Error = 28
	/*Can't fork process error.*/
	ErrCantFork Error = 29
	/*Invalid data error.*/
	ErrInvalidData Error = 30
	/*Invalid parameter error.*/
	ErrInvalidParameter Error = 31
	/*Already exists error.*/
	ErrAlreadyExists Error = 32
	/*Does not exist error.*/
	ErrDoesNotExist Error = 33
	/*Database: Read error.*/
	ErrDatabaseCantRead Error = 34
	/*Database: Write error.*/
	ErrDatabaseCantWrite Error = 35
	/*Compilation failed error.*/
	ErrCompilationFailed Error = 36
	/*Method not found error.*/
	ErrMethodNotFound Error = 37
	/*Linking failed error.*/
	ErrLinkFailed Error = 38
	/*Script failed error.*/
	ErrScriptFailed Error = 39
	/*Cycling link (import cycle) error.*/
	ErrCyclicLink Error = 40
	/*Invalid declaration error.*/
	ErrInvalidDeclaration Error = 41
	/*Duplicate symbol error.*/
	ErrDuplicateSymbol Error = 42
	/*Parse error.*/
	ErrParseError Error = 43
	/*Busy error.*/
	ErrBusy Error = 44
	/*Skip error.*/
	ErrSkip Error = 45
	/*Help error. Used internally when passing [code]--version[/code] or [code]--help[/code] as executable options.*/
	ErrHelp Error = 46
	/*Bug error, caused by an implementation issue in the method.
	  [b]Note:[/b] If a built-in method returns this code, please open an issue on [url=https://github.com/godotengine/godot/issues]the GitHub Issue Tracker[/url].*/
	ErrBug Error = 47
	/*Printer on fire error (This is an easter egg, no built-in methods return this error code).*/
	ErrPrinterOnFire Error = 48
)

type PropertyHint int64

type PropertyUsageFlags int64

type MethodFlags int64

type VariantType int64

const (
	/*Variable is [code]null[/code].*/
	TypeNil VariantType = 0
	/*Variable is of type [bool].*/
	TypeBool VariantType = 1
	/*Variable is of type [int].*/
	TypeInt VariantType = 2
	/*Variable is of type [float].*/
	TypeFloat VariantType = 3
	/*Variable is of type [String].*/
	TypeString VariantType = 4
	/*Variable is of type [Vector2].*/
	TypeVector2 VariantType = 5
	/*Variable is of type [Vector2i].*/
	TypeVector2i VariantType = 6
	/*Variable is of type [Rect2].*/
	TypeRect2 VariantType = 7
	/*Variable is of type [Rect2i].*/
	TypeRect2i VariantType = 8
	/*Variable is of type [Vector3].*/
	TypeVector3 VariantType = 9
	/*Variable is of type [Vector3i].*/
	TypeVector3i VariantType = 10
	/*Variable is of type [Transform2D].*/
	TypeTransform2d VariantType = 11
	/*Variable is of type [Vector4].*/
	TypeVector4 VariantType = 12
	/*Variable is of type [Vector4i].*/
	TypeVector4i VariantType = 13
	/*Variable is of type [Plane].*/
	TypePlane VariantType = 14
	/*Variable is of type [Quaternion].*/
	TypeQuaternion VariantType = 15
	/*Variable is of type [AABB].*/
	TypeAabb VariantType = 16
	/*Variable is of type [Basis].*/
	TypeBasis VariantType = 17
	/*Variable is of type [Transform3D].*/
	TypeTransform3d VariantType = 18
	/*Variable is of type [Projection].*/
	TypeProjection VariantType = 19
	/*Variable is of type [Color].*/
	TypeColor VariantType = 20
	/*Variable is of type [StringName].*/
	TypeStringName VariantType = 21
	/*Variable is of type [NodePath].*/
	TypeNodePath VariantType = 22
	/*Variable is of type [RID].*/
	TypeRid VariantType = 23
	/*Variable is of type [Object].*/
	TypeObject VariantType = 24
	/*Variable is of type [Callable].*/
	TypeCallable VariantType = 25
	/*Variable is of type [Signal].*/
	TypeSignal VariantType = 26
	/*Variable is of type [Dictionary].*/
	TypeDictionary VariantType = 27
	/*Variable is of type [Array].*/
	TypeArray VariantType = 28
	/*Variable is of type [PackedByteArray].*/
	TypePackedByteArray VariantType = 29
	/*Variable is of type [PackedInt32Array].*/
	TypePackedInt32Array VariantType = 30
	/*Variable is of type [PackedInt64Array].*/
	TypePackedInt64Array VariantType = 31
	/*Variable is of type [PackedFloat32Array].*/
	TypePackedFloat32Array VariantType = 32
	/*Variable is of type [PackedFloat64Array].*/
	TypePackedFloat64Array VariantType = 33
	/*Variable is of type [PackedStringArray].*/
	TypePackedStringArray VariantType = 34
	/*Variable is of type [PackedVector2Array].*/
	TypePackedVector2Array VariantType = 35
	/*Variable is of type [PackedVector3Array].*/
	TypePackedVector3Array VariantType = 36
	/*Variable is of type [PackedColorArray].*/
	TypePackedColorArray VariantType = 37
	/*Represents the size of the [enum Variant.Type] enum.*/
	TypeMax VariantType = 38
)

type VariantOperator int64

func (ctx Context) Sin(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sin(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Cos(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cos(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Tan(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.tan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Sinh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sinh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Cosh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cosh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Tanh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.tanh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Asin(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.asin(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Acos(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.acos(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Atan(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Atan2(y Float, x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, y)
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atan2(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Asinh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.asinh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Acosh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.acosh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Atanh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atanh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Sqrt(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sqrt(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Fmod(x Float, y Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.fmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Fposmod(x Float, y Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.fposmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Posmod(x Int, y Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.posmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Floor(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.floor(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Floorf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.floorf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Floori(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.floori(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Ceil(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.ceil(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Ceilf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.ceilf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Ceili(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.ceili(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Round(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.round(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Roundf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.roundf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Roundi(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.roundi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Abs(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.abs(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Absf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.absf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Absi(x Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.absi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Sign(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.sign(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Signf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.signf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Signi(x Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.signi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Snapped(x Variant, step Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	callframe.Arg(frame, mmm.Get(step))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.snapped(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Snappedf(x Float, step Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, step)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.snappedf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Snappedi(x Float, step Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, step)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.snappedi(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Pow(base Float, exp Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	callframe.Arg(frame, exp)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.pow(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Log(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.log(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Exp(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.exp(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsNan(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_nan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsInf(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_inf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsEqualApprox(a Float, b Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_equal_approx(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsZeroApprox(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_zero_approx(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsFinite(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_finite(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Ease(x Float, curve Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, curve)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.ease(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) StepDecimals(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.step_decimals(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Lerp(from Variant, to Variant, weight Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(from))
	callframe.Arg(frame, mmm.Get(to))
	callframe.Arg(frame, mmm.Get(weight))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.lerp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Lerpf(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.lerpf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) CubicInterpolate(from Float, to Float, pre Float, post Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) CubicInterpolateAngle(from Float, to Float, pre Float, post Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_angle(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) CubicInterpolateInTime(from Float, to Float, pre Float, post Float, weight Float, to_t Float, pre_t Float, post_t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	callframe.Arg(frame, to_t)
	callframe.Arg(frame, pre_t)
	callframe.Arg(frame, post_t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_in_time(r_ret.Uintptr(), frame.Array(0), 8)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) CubicInterpolateAngleInTime(from Float, to Float, pre Float, post Float, weight Float, to_t Float, pre_t Float, post_t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	callframe.Arg(frame, to_t)
	callframe.Arg(frame, pre_t)
	callframe.Arg(frame, post_t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_angle_in_time(r_ret.Uintptr(), frame.Array(0), 8)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) BezierInterpolate(start Float, control_1 Float, control_2 Float, end Float, t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, start)
	callframe.Arg(frame, control_1)
	callframe.Arg(frame, control_2)
	callframe.Arg(frame, end)
	callframe.Arg(frame, t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.bezier_interpolate(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) BezierDerivative(start Float, control_1 Float, control_2 Float, end Float, t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, start)
	callframe.Arg(frame, control_1)
	callframe.Arg(frame, control_2)
	callframe.Arg(frame, end)
	callframe.Arg(frame, t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.bezier_derivative(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) AngleDifference(from Float, to Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.angle_difference(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) LerpAngle(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.lerp_angle(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) InverseLerp(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.inverse_lerp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Remap(value Float, istart Float, istop Float, ostart Float, ostop Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, istart)
	callframe.Arg(frame, istop)
	callframe.Arg(frame, ostart)
	callframe.Arg(frame, ostop)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.remap(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Smoothstep(from Float, to Float, x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.smoothstep(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) MoveToward(from Float, to Float, delta Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, delta)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.move_toward(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RotateToward(from Float, to Float, delta Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, delta)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.rotate_toward(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) DegToRad(deg Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, deg)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.deg_to_rad(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RadToDeg(rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.rad_to_deg(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) LinearToDb(lin Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, lin)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.linear_to_db(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) DbToLinear(db Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, db)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.db_to_linear(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Wrap(value Variant, min Variant, max Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(min))
	callframe.Arg(frame, mmm.Get(max))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.wrap(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Wrapi(value Int, min Int, max Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.wrapi(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Wrapf(value Float, min Float, max Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.wrapf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Max(arg1 Variant, arg2 Variant, args ...Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	callframe.Arg(frame, mmm.Get(arg2))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.max(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Maxi(a Int, b Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.maxi(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Maxf(a Float, b Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.maxf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Min(arg1 Variant, arg2 Variant, args ...Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	callframe.Arg(frame, mmm.Get(arg2))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.min(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Mini(a Int, b Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.mini(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Minf(a Float, b Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.minf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Clamp(value Variant, min Variant, max Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(min))
	callframe.Arg(frame, mmm.Get(max))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.clamp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Clampi(value Int, min Int, max Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.clampi(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Clampf(value Float, min Float, max Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.clampf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) NearestPo2(value Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.nearest_po2(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Pingpong(value Float, length Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.pingpong(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Randomize() {
	var frame = callframe.New()
	var r_ret callframe.Nil
	ctx.API.utility.randomize(r_ret.Uintptr(), frame.Array(0), 0)
	frame.Free()
}

func (ctx Context) Randi() Int {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.randi(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Randf() Float {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randf(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RandiRange(from Int, to Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.randi_range(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RandfRange(from Float, to Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randf_range(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Randfn(mean Float, deviation Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, mean)
	callframe.Arg(frame, deviation)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randfn(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) Seed(base Int) {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	var r_ret callframe.Nil
	ctx.API.utility.seed(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) RandFromSeed(seed Int) PackedInt64Array {
	var frame = callframe.New()
	callframe.Arg(frame, seed)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.rand_from_seed(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Weakref(obj Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(obj))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.weakref(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Typeof(variable Variant) Int {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.typeof(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) TypeConvert(variant Variant, atype Int) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variant))
	callframe.Arg(frame, atype)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.type_convert(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Str(arg1 Variant, args ...Variant) String {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.str(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) ErrorString(error Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, error)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.error_string(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) TypeToString(atype Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, atype)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.type_string(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Print(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.print(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) PrintRich(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.print_rich(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) Printerr(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.printerr(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) Printt(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.printt(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) Prints(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.prints(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) Printraw(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.printraw(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) PrintVerbose(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.print_verbose(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) PushError(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.push_error(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) PushWarning(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	ctx.API.utility.push_warning(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Context) VarToStr(variable Variant) String {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.var_to_str(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) StrToVar(s String) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(s))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.str_to_var(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) VarToBytes(variable Variant) PackedByteArray {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.var_to_bytes(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) BytesToVar(bytes PackedByteArray) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(bytes))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.bytes_to_var(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) VarToBytesWithObjects(variable Variant) PackedByteArray {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.var_to_bytes_with_objects(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) BytesToVarWithObjects(bytes PackedByteArray) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(bytes))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.bytes_to_var_with_objects(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Context) Hash(variable Variant) Int {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.hash(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) InstanceFromId(instance_id Int) Object {
	var frame = callframe.New()
	callframe.Arg(frame, instance_id)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.instance_from_id(r_ret.Uintptr(), frame.Array(0), 1)
	var ret Object
	ret.SetPointer(PointerMustAssertInstanceID(ctx, r_ret.Get()))
	frame.Free()
	return ret
}

func (ctx Context) IsInstanceIdValid(id Int) bool {
	var frame = callframe.New()
	callframe.Arg(frame, id)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_instance_id_valid(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsInstanceValid(instance Variant) bool {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(instance))
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_instance_valid(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RidAllocateId() Int {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.rid_allocate_id(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) RidFromInt64(base Int) RID {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	var r_ret = callframe.Ret[RID](frame)
	ctx.API.utility.rid_from_int64(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Context) IsSame(a Variant, b Variant) bool {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(a))
	callframe.Arg(frame, mmm.Get(b))
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_same(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

type Vector2Axis int64

type Vector2iAxis int64

type Vector3Axis int64

type Vector3iAxis int64

type Vector4Axis int64

type Vector4iAxis int64

type ProjectionPlanes int64

/*
Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" and "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self String) CasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.casecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self String) NocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.nocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self String) NaturalcasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.naturalcasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self String) NaturalnocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.naturalnocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of characters in the string. Empty strings ([code]""[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self String) Length() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.length(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position.
*/
//go:nosplit
func (self String) Substr(ctx Context, from Int, len Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, len)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.substr(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns the original string if [param delimiter] does not occur in the string. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print("i/am/example/hi".get_slice("/", 2)) # Prints "example"
[/codeblock]
*/
//go:nosplit
func (self String) GetSlice(ctx Context, delimiter String, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
*/
//go:nosplit
func (self String) GetSlicec(ctx Context, delimiter Int, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, delimiter)
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_slicec(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]).
*/
//go:nosplit
func (self String) GetSliceCount(delimiter String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_slice_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print("Team".find("I")) # Prints -1

print("Potato".find("t"))    # Prints 2
print("Potato".find("t", 3)) # Prints 4
print("Potato".find("t", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print("Team".Find("I")); // Prints -1

GD.Print("Potato".Find("t"));    // Prints 2
GD.Print("Potato".Find("t", 3)); // Prints 4
GD.Print("Potato".Find("t", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator.
*/
//go:nosplit
func (self String) Find(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self String) Count(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self String) Countn(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.countn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string.
*/
//go:nosplit
func (self String) Findn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.findn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find].
*/
//go:nosplit
func (self String) Rfind(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn].
*/
//go:nosplit
func (self String) Rfindn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.rfindn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Does a simple expression match (also called "glob" or "globbing"), where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self String) Match(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.match(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Does a simple [b]case-insensitive[/b] expression match, where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self String) Matchn(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.matchn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with].
*/
//go:nosplit
func (self String) BeginsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.begins_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with].
*/
//go:nosplit
func (self String) EndsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.ends_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # Prints true
print("Word!".is_subsequence_of(text))    # Prints true
print("Window".is_subsequence_of(text))   # Prints false
print("".is_subsequence_of(text))         # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsSubsequenceOf(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_subsequence_of(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b].
*/
//go:nosplit
func (self String) IsSubsequenceOfn(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_subsequence_ofn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print("Get up!".bigrams()) # Prints ["Ge", "et", "t ", " u", "up", "p!"]
[/codeblock]
*/
//go:nosplit
func (self String) Bigrams(ctx Context) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.bigrams(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print("ABC123".similarity("ABC123")) # Prints 1.0
print("ABC123".similarity("XYZ456")) # Prints 0.0
print("ABC123".similarity("123ABC")) # Prints 0.8
print("ABC123".similarity("abc123")) # Prints 0.4
[/codeblock]
*/
//go:nosplit
func (self String) Similarity(text String) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.similarity(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints "Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it."
var use_array_values = "Waiting for {0} is a play by {1}, and {0} Engine is named after it."
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# Prints "User 42 is Godot."
print("User {id} is {name}.".format({"id": 42, "name": "Godot"}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints "User 42 is Godot."
print("User {} is {}.".format([42, "Godot"], "{}"))
print("User {id} is {name}.".format([["id", 42], ["name", "Godot"]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] The replacement of placeholders is not done all at once, instead each placeholder is replaced in the order they are passed, this means that if one of the replacement strings contains a key it will also be replaced. This can be very powerful, but can also cause unexpected results if you are not careful. If you do not need to perform replacement in the replacement strings, make sure your replacements do not contain placeholders to ensure reliable results.
[codeblock]
print("{0} {1}".format(["{1}", "x"]))                       # Prints "x x".
print("{0} {1}".format(["x", "{0}"]))                       # Prints "x {0}".
print("{foo} {bar}".format({"foo": "{bar}", "bar": "baz"})) # Prints "baz baz".
print("{foo} {bar}".format({"bar": "baz", "foo": "{bar}"})) # Prints "{bar} baz".
[/codeblock]
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with "$"[/url], instead.
*/
//go:nosplit
func (self String) Format(ctx Context, values Variant, placeholder String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(values))
	callframe.Arg(frame, mmm.Get(placeholder))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.format(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Replaces all occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self String) Replace(ctx Context, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.replace(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self String) Replacen(ctx Context, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.replacen(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string.
*/
//go:nosplit
func (self String) Repeat(ctx Context, count Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, count)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.repeat(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the copy of this string in reverse order.
*/
//go:nosplit
func (self String) Reverse(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Inserts [param what] at the given [param position] in the string.
*/
//go:nosplit
func (self String) Insert(ctx Context, position Int, what String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code].
*/
//go:nosplit
func (self String) Erase(ctx Context, position Int, chars Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, chars)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
"move_local_x".capitalize()   # Returns "Move Local X"
"sceneFile_path".capitalize() # Returns "Scene File Path"
"2D, FPS, PNG".capitalize()   # Returns "2d, Fps, Png"
[/gdscript]
[csharp]
"move_local_x".Capitalize();   // Returns "Move Local X"
"sceneFile_path".Capitalize(); // Returns "Scene File Path"
"2D, FPS, PNG".Capitalize();   // Returns "2d, Fps, Png"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Capitalize(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.capitalize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]camelCase[/code].
*/
//go:nosplit
func (self String) ToCamelCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_camel_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]PascalCase[/code].
*/
//go:nosplit
func (self String) ToPascalCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_pascal_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as "2D") together.
[codeblocks]
[gdscript]
"Node2D".to_snake_case()               # Returns "node_2d"
"2nd place".to_snake_case()            # Returns "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # Returns "texture_3d_asset_folder"
[/gdscript]
[csharp]
"Node2D".ToSnakeCase();               // Returns "node_2d"
"2nd place".ToSnakeCase();            // Returns "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // Returns "texture_3d_asset_folder"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) ToSnakeCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_snake_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints "One"
print(some_array[1])     # Prints "Two"
print(some_array[2])     # Prints "Three,Four"
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // Prints "One"
GD.Print(someArray[1]); // Prints "Two"
GD.Print(someArray[2]); // Prints "Three"
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead.
*/
//go:nosplit
func (self String) Split(ctx Context, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.split(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints "One,Two,Three"
print(some_array[1])     # Prints "Four"
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Rsplit(ctx Context, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.rsplit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = "1,2,4.5".split_floats(",")         # a is [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c is [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b is [1.0, 4.5]
[/codeblock]
*/
//go:nosplit
func (self String) SplitFloats(ctx Context, delimiter String, allow_empty bool) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.split_floats(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # Prints "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # Prints "Apple---Orange---Pear---Kiwi"
[/gdscript]
[csharp]
var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// In C#, this method is static.
GD.Print(string.Join(", ", fruits));  // Prints "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // Prints "Apple---Orange---Pear---Kiwi"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Join(ctx Context, parts PackedStringArray) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(parts))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]UPPERCASE[/code].
*/
//go:nosplit
func (self String) ToUpper(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_upper(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]lowercase[/code].
*/
//go:nosplit
func (self String) ToLower(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_lower(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print("Hello World!".left(3))  # Prints "Hel"
print("Hello World!".left(-4)) # Prints "Hello Wo"
[/codeblock]
*/
//go:nosplit
func (self String) Left(ctx Context, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.left(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print("Hello World!".right(3))  # Prints "ld!"
print("Hello World!".right(-4)) # Prints "o World!"
[/codeblock]
*/
//go:nosplit
func (self String) Right(ctx Context, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.right(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end.
*/
//go:nosplit
func (self String) StripEdges(ctx Context, left bool, right bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, left)
	callframe.Arg(frame, right)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.strip_edges(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces.
*/
//go:nosplit
func (self String) StripEscapes(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.strip_escapes(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters.
*/
//go:nosplit
func (self String) Lstrip(ctx Context, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.lstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters.
*/
//go:nosplit
func (self String) Rstrip(ctx Context, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.rstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = "/path/to/file.txt".get_extension() # a is "txt"
var b = "cool.txt".get_extension()          # b is "txt"
var c = "cool.font.tres".get_extension()    # c is "tres"
var d = ".pack1".get_extension()            # d is "pack1"

var e = "file.txt.".get_extension()  # e is ""
var f = "file.txt..".get_extension() # f is ""
var g = "txt".get_extension()        # g is ""
var h = "".get_extension()           # h is ""
[/codeblock]
*/
//go:nosplit
func (self String) GetExtension(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_extension(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = "/path/to/file.txt".get_basename() # base is "/path/to/file"
[/codeblock]
*/
//go:nosplit
func (self String) GetBasename(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_basename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]"this/is".path_join("path") == "this/is/path"[/code].
*/
//go:nosplit
func (self String) PathJoin(ctx Context, file String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(file))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.path_join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the character code at position [param at].
*/
//go:nosplit
func (self String) UnicodeAt(at Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.unicode_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]"\t\t"[/code], or four spaces using [code]"    "[/code].
*/
//go:nosplit
func (self String) Indent(ctx Context, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.indent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation.
*/
//go:nosplit
func (self String) Dedent(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.dedent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self String) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String].
*/
//go:nosplit
func (self String) Md5Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.md5_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String].
*/
//go:nosplit
func (self String) Sha1Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.sha1_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String].
*/
//go:nosplit
func (self String) Sha256Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.sha256_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Md5Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.md5_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Sha1Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.sha1_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Sha256Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.sha256_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""[/code]). See also [method length].
*/
//go:nosplit
func (self String) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print("Node".contains("de")) # Prints true
print("team".contains("I"))  # Prints false
print("I" in "team")         # Prints false
[/gdscript]
[csharp]
GD.Print("Node".Contains("de")); // Prints true
GD.Print("team".Contains("I"));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find].
*/
//go:nosplit
func (self String) Contains(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.contains(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]"res://"[/code], [code]"user://"[/code], [code]"C:\"[/code], [code]"/"[/code], etc.
*/
//go:nosplit
func (self String) IsAbsolutePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_absolute_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]"./"[/code]. This method is the opposite of [method is_absolute_path].
*/
//go:nosplit
func (self String) IsRelativePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_relative_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]"./"[/code], and all the unnecessary [code]".."[/code] and [code]"/"[/code].
[codeblock]
var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # Prints "path/file"
[/codeblock]
*/
//go:nosplit
func (self String) SimplifyPath(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.simplify_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = "/path/to/file.txt".get_base_dir() # dir_path is "/path/to"
[/codeblock]
*/
//go:nosplit
func (self String) GetBaseDir(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_base_dir(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = "/path/to/icon.png".get_file() # file is "icon.png"
[/codeblock]
*/
//go:nosplit
func (self String) GetFile(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.get_file(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]"[/code]) characters are also escaped.
*/
//go:nosplit
func (self String) XmlEscape(ctx Context, escape_quotes bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, escape_quotes)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.xml_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard.
*/
//go:nosplit
func (self String) XmlUnescape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.xml_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also [method uri_decode].
[codeblocks]
[gdscript]
var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/gdscript]
[csharp]
var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) UriEncode(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.uri_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also [method uri_encode].
[codeblocks]
[gdscript]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/gdscript]
[csharp]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) UriDecode(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.uri_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the C language standard.
*/
//go:nosplit
func (self String) CEscape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.c_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\"[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence.
*/
//go:nosplit
func (self String) CUnescape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.c_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary.
*/
//go:nosplit
func (self String) JsonEscape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.json_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]"[/code] [code]%[/code]) replaced with underscores.
*/
//go:nosplit
func (self String) ValidateNodeName(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.validate_node_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores.
*/
//go:nosplit
func (self String) ValidateFilename(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.validate_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print("node_2d".is_valid_identifier())    # Prints true
print("TYPE_FLOAT".is_valid_identifier()) # Prints true
print("1st_method".is_valid_identifier()) # Prints false
print("MyMethod#2".is_valid_identifier()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self String) IsValidIdentifier() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_identifier(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print("7".is_valid_int())    # Prints true
print("1.65".is_valid_int()) # Prints false
print("Hi".is_valid_int())   # Prints false
print("+3".is_valid_int())   # Prints true
print("-12".is_valid_int())  # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsValidInt() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print("1.7".is_valid_float())   # Prints true
print("24".is_valid_float())    # Prints true
print("7e3".is_valid_float())   # Prints true
print("Hello".is_valid_float()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self String) IsValidFloat() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]"0x"[/code] to be considered valid.
[codeblock]
print("A08E".is_valid_hex_number())    # Prints true
print("-AbCdEf".is_valid_hex_number()) # Prints true
print("2.5".is_valid_hex_number())     # Prints false

print("0xDEADC0DE".is_valid_hex_number(true)) # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsValidHexNumber(with_prefix bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, with_prefix)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_hex_number(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html].
*/
//go:nosplit
func (self String) IsValidHtmlColor() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_html_color(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]"0.0.0.0"[/code] and [code]"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"[/code] as valid.
*/
//go:nosplit
func (self String) IsValidIpAddress() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_ip_address(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code]*[/code] [code]"[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]).
*/
//go:nosplit
func (self String) IsValidFilename() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.is_valid_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = "123".to_int()    # a is 123
var b = "x1y2z3".to_int() # b is 123
var c = "-1.2.3".to_int() # c is -1
var d = "Hello!".to_int() # d is 0
[/codeblock]
*/
//go:nosplit
func (self String) ToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = "12.35".to_float()  # a is 12.35
var b = "1.2.3".to_float()  # b is 1.2
var c = "12xy3".to_float()  # c is 12.0
var d = "1e3".to_float()    # d is 1000.0
var e = "Hello!".to_float() # e is 0.0
[/codeblock]
*/
//go:nosplit
func (self String) ToFloat() Float {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]"0x"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("0xff".hex_to_int()) # Prints 255
print("ab".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print("0xff".HexToInt()); // Prints 255
GD.Print("ab".HexToInt());   // Prints 171
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) HexToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.hex_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]"0b"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("101".bin_to_int())   # Prints 5
print("0b101".bin_to_int()) # Prints 5
print("-0b10".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print("101".BinToInt());   // Prints 5
GD.Print("0b101".BinToInt()); // Prints 5
GD.Print("-0b10".BinToInt()); // Prints -2
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) BinToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.bin_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad].
*/
//go:nosplit
func (self String) Lpad(ctx Context, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.lpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad].
*/
//go:nosplit
func (self String) Rpad(ctx Context, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.rpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point.
*/
//go:nosplit
func (self String) PadDecimals(ctx Context, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.pad_decimals(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point.
*/
//go:nosplit
func (self String) PadZeros(ctx Context, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.pad_zeros(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes the given [param prefix] from the start of the string, or returns the string unchanged.
*/
//go:nosplit
func (self String) TrimPrefix(ctx Context, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.trim_prefix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes the given [param suffix] from the end of the string, or returns the string unchanged.
*/
//go:nosplit
func (self String) TrimSuffix(ctx Context, suffix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(suffix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.trim_suffix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. This is the inverse of [method PackedByteArray.get_string_from_ascii].
*/
//go:nosplit
func (self String) ToAsciiBuffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_ascii_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of [method PackedByteArray.get_string_from_utf8].
*/
//go:nosplit
func (self String) ToUtf8Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_utf8_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf16].
*/
//go:nosplit
func (self String) ToUtf16Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_utf16_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf32].
*/
//go:nosplit
func (self String) ToUtf32Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_utf32_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # outputs "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) HexDecode(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.hex_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_wchar].
*/
//go:nosplit
func (self String) ToWcharBuffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.to_wchar_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the given [param number] to a string representation, in scientific notation.
[codeblocks]
[gdscript]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
[/gdscript]
[csharp]
// This method is not implemented in C#.
// Use `string.ToString()` with "e" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString("e1")); // Prints -5.2e+008
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, this method is not implemented. To achieve similar results, see C#'s [url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings]Standard numeric format strings[/url]
*/
//go:nosplit
func (self String) NumScientific(ctx Context, number Float) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, number)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.num_scientific(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts a [float] to a string representation of a decimal number, with the number of decimal places specified in [param decimals].
If [param decimals] is [code]-1[/code] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
[b]Example:[/b]
[codeblock]
String.num(3.141593)     # Returns "3.141593"
String.num(3.141593, 3)  # Returns "3.142"
String.num(3.14159300)   # Returns "3.141593"

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns "42.13"

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns "-0.00000123454321"
String.num(-10000.0000012345432123454321) # Returns "-10000.0000012345"
[/codeblock]
*/
//go:nosplit
func (self String) Num(ctx Context, number Float, decimals Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, decimals)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.num(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the given [param number] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase.
*/
//go:nosplit
func (self String) NumInt64(ctx Context, number Int, base Int, capitalize_hex bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, base)
	callframe.Arg(frame, capitalize_hex)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.num_int64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the given unsigned [int] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase.
*/
//go:nosplit
func (self String) NumUint64(ctx Context, number Int, base Int, capitalize_hex bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, base)
	callframe.Arg(frame, capitalize_hex)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.num_uint64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a single Unicode character from the decimal [param char]. You may use [url=https://unicodelookup.com/]unicodelookup.com[/url] or [url=https://www.unicode.org/charts/]unicode.org[/url] as points of reference.
[codeblock]
print(String.chr(65))     # Prints "A"
print(String.chr(129302)) # Prints "🤖" (robot face emoji)
[/codeblock]
*/
//go:nosplit
func (self String) Chr(ctx Context, char Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, char)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.chr(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts [param size] which represents a number of bytes into a human-readable form.
The result is in [url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes]IEC prefix format[/url], which may end in either [code]"B"[/code], [code]"KiB"[/code], [code]"MiB"[/code], [code]"GiB"[/code], [code]"TiB"[/code], [code]"PiB"[/code], or [code]"EiB"[/code].
*/
//go:nosplit
func (self String) HumanizeSize(ctx Context, size Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, size)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.String.humanize_size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" and "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self StringName) CasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.casecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method naturalcasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self StringName) NocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.nocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method nocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self StringName) NaturalcasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.naturalcasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method nocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self StringName) NaturalnocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.naturalnocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of characters in the string. Empty strings ([code]""[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self StringName) Length() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.length(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position.
*/
//go:nosplit
func (self StringName) Substr(ctx Context, from Int, len Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, len)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.substr(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print("i/am/example/hi".get_slice("/", 2)) # Prints "example"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetSlice(ctx Context, delimiter String, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
*/
//go:nosplit
func (self StringName) GetSlicec(ctx Context, delimiter Int, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, delimiter)
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_slicec(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]).
*/
//go:nosplit
func (self StringName) GetSliceCount(delimiter String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_slice_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print("Team".find("I")) # Prints -1

print("Potato".find("t"))    # Prints 2
print("Potato".find("t", 3)) # Prints 4
print("Potato".find("t", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print("Team".Find("I")); // Prints -1

GD.Print("Potato".Find("t"));    // Prints 2
GD.Print("Potato".Find("t", 3)); // Prints 4
GD.Print("Potato".Find("t", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator.
*/
//go:nosplit
func (self StringName) Find(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self StringName) Count(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self StringName) Countn(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.countn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string.
*/
//go:nosplit
func (self StringName) Findn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.findn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find].
*/
//go:nosplit
func (self StringName) Rfind(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn].
*/
//go:nosplit
func (self StringName) Rfindn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.rfindn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Does a simple expression match (also called "glob" or "globbing"), where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self StringName) Match(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.match(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Does a simple [b]case-insensitive[/b] expression match, where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self StringName) Matchn(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.matchn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with].
*/
//go:nosplit
func (self StringName) BeginsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.begins_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with].
*/
//go:nosplit
func (self StringName) EndsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.ends_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # Prints true
print("Word!".is_subsequence_of(text))    # Prints true
print("Window".is_subsequence_of(text))   # Prints false
print("".is_subsequence_of(text))         # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsSubsequenceOf(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_subsequence_of(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b].
*/
//go:nosplit
func (self StringName) IsSubsequenceOfn(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_subsequence_ofn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print("Get up!".bigrams()) # Prints ["Ge", "et", "t ", " u", "up", "p!"]
[/codeblock]
*/
//go:nosplit
func (self StringName) Bigrams(ctx Context) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.bigrams(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print("ABC123".similarity("ABC123")) # Prints 1.0
print("ABC123".similarity("XYZ456")) # Prints 0.0
print("ABC123".similarity("123ABC")) # Prints 0.8
print("ABC123".similarity("abc123")) # Prints 0.4
[/codeblock]
*/
//go:nosplit
func (self StringName) Similarity(text String) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.similarity(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints "Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it."
var use_array_values = "Waiting for {0} is a play by {1}, and {0} Engine is named after it."
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# Prints "User 42 is Godot."
print("User {id} is {name}.".format({"id": 42, "name": "Godot"}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints "User 42 is Godot."
print("User {} is {}.".format([42, "Godot"], "{}"))
print("User {id} is {name}.".format([["id", 42], ["name", "Godot"]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with "$"[/url], instead.
*/
//go:nosplit
func (self StringName) Format(ctx Context, values Variant, placeholder String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(values))
	callframe.Arg(frame, mmm.Get(placeholder))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.format(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Replaces all occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self StringName) Replace(ctx Context, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.replace(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self StringName) Replacen(ctx Context, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.replacen(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string.
*/
//go:nosplit
func (self StringName) Repeat(ctx Context, count Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, count)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.repeat(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the copy of this string in reverse order.
*/
//go:nosplit
func (self StringName) Reverse(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Inserts [param what] at the given [param position] in the string.
*/
//go:nosplit
func (self StringName) Insert(ctx Context, position Int, what String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code].
*/
//go:nosplit
func (self StringName) Erase(ctx Context, position Int, chars Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, chars)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
"move_local_x".capitalize()   # Returns "Move Local X"
"sceneFile_path".capitalize() # Returns "Scene File Path"
"2D, FPS, PNG".capitalize()   # Returns "2d, Fps, Png"
[/gdscript]
[csharp]
"move_local_x".Capitalize();   // Returns "Move Local X"
"sceneFile_path".Capitalize(); // Returns "Scene File Path"
"2D, FPS, PNG".Capitalize();   // Returns "2d, Fps, Png"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Capitalize(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.capitalize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]camelCase[/code].
*/
//go:nosplit
func (self StringName) ToCamelCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_camel_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]PascalCase[/code].
*/
//go:nosplit
func (self StringName) ToPascalCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_pascal_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as "2D") together.
[codeblocks]
[gdscript]
"Node2D".to_snake_case()               # Returns "node_2d"
"2nd place".to_snake_case()            # Returns "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # Returns "texture_3d_asset_folder"
[/gdscript]
[csharp]
"Node2D".ToSnakeCase();               // Returns "node_2d"
"2nd place".ToSnakeCase();            // Returns "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // Returns "texture_3d_asset_folder"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) ToSnakeCase(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_snake_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints "One"
print(some_array[1])     # Prints "Two"
print(some_array[2])     # Prints "Three,Four"
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // Prints "One"
GD.Print(someArray[1]); // Prints "Two"
GD.Print(someArray[2]); // Prints "Three"
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead.
*/
//go:nosplit
func (self StringName) Split(ctx Context, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.split(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints "One,Two,Three"
print(some_array[1])     # Prints "Four"
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Rsplit(ctx Context, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.rsplit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = "1,2,4.5".split_floats(",")         # a is [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c is [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b is [1.0, 4.5]
[/codeblock]
*/
//go:nosplit
func (self StringName) SplitFloats(ctx Context, delimiter String, allow_empty bool) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.split_floats(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # Prints "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # Prints "Apple---Orange---Pear---Kiwi"
[/gdscript]
[csharp]
var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// In C#, this method is static.
GD.Print(string.Join(", ", fruits));  // Prints "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // Prints "Apple---Orange---Pear---Kiwi"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Join(ctx Context, parts PackedStringArray) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(parts))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]UPPERCASE[/code].
*/
//go:nosplit
func (self StringName) ToUpper(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_upper(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the string converted to [code]lowercase[/code].
*/
//go:nosplit
func (self StringName) ToLower(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_lower(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print("Hello World!".left(3))  # Prints "Hel"
print("Hello World!".left(-4)) # Prints "Hello Wo"
[/codeblock]
*/
//go:nosplit
func (self StringName) Left(ctx Context, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.left(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print("Hello World!".right(3))  # Prints "ld!"
print("Hello World!".right(-4)) # Prints "o World!"
[/codeblock]
*/
//go:nosplit
func (self StringName) Right(ctx Context, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.right(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end.
*/
//go:nosplit
func (self StringName) StripEdges(ctx Context, left bool, right bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, left)
	callframe.Arg(frame, right)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.strip_edges(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces.
*/
//go:nosplit
func (self StringName) StripEscapes(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.strip_escapes(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters.
*/
//go:nosplit
func (self StringName) Lstrip(ctx Context, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.lstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters.
*/
//go:nosplit
func (self StringName) Rstrip(ctx Context, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.rstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = "/path/to/file.txt".get_extension() # a is "txt"
var b = "cool.txt".get_extension()          # b is "txt"
var c = "cool.font.tres".get_extension()    # c is "tres"
var d = ".pack1".get_extension()            # d is "pack1"

var e = "file.txt.".get_extension()  # e is ""
var f = "file.txt..".get_extension() # f is ""
var g = "txt".get_extension()        # g is ""
var h = "".get_extension()           # h is ""
[/codeblock]
*/
//go:nosplit
func (self StringName) GetExtension(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_extension(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = "/path/to/file.txt".get_basename() # base is "/path/to/file"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetBasename(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_basename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]"this/is".path_join("path") == "this/is/path"[/code].
*/
//go:nosplit
func (self StringName) PathJoin(ctx Context, file String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(file))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.path_join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the character code at position [param at].
*/
//go:nosplit
func (self StringName) UnicodeAt(at Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.unicode_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]"\t\t"[/code], or four spaces using [code]"    "[/code].
*/
//go:nosplit
func (self StringName) Indent(ctx Context, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.indent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation.
*/
//go:nosplit
func (self StringName) Dedent(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.dedent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String].
*/
//go:nosplit
func (self StringName) Md5Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.md5_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String].
*/
//go:nosplit
func (self StringName) Sha1Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.sha1_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String].
*/
//go:nosplit
func (self StringName) Sha256Text(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.sha256_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Md5Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.md5_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Sha1Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.sha1_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Sha256Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.sha256_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""[/code]). See also [method length].
*/
//go:nosplit
func (self StringName) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print("Node".contains("de")) # Prints true
print("team".contains("I"))  # Prints false
print("I" in "team")         # Prints false
[/gdscript]
[csharp]
GD.Print("Node".Contains("de")); // Prints true
GD.Print("team".Contains("I"));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find].
*/
//go:nosplit
func (self StringName) Contains(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.contains(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]"res://"[/code], [code]"user://"[/code], [code]"C:\"[/code], [code]"/"[/code], etc.
*/
//go:nosplit
func (self StringName) IsAbsolutePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_absolute_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]"./"[/code]. This method is the opposite of [method is_absolute_path].
*/
//go:nosplit
func (self StringName) IsRelativePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_relative_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]"./"[/code], and all the unnecessary [code]".."[/code] and [code]"/"[/code].
[codeblock]
var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # Prints "path/file"
[/codeblock]
*/
//go:nosplit
func (self StringName) SimplifyPath(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.simplify_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = "/path/to/file.txt".get_base_dir() # dir_path is "/path/to"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetBaseDir(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_base_dir(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = "/path/to/icon.png".get_file() # file is "icon.png"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetFile(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.get_file(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]"[/code]) characters are also escaped.
*/
//go:nosplit
func (self StringName) XmlEscape(ctx Context, escape_quotes bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, escape_quotes)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.xml_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard.
*/
//go:nosplit
func (self StringName) XmlUnescape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.xml_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request.
[codeblocks]
[gdscript]
var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/gdscript]
[csharp]
var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) UriEncode(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.uri_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request.
[codeblocks]
[gdscript]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/gdscript]
[csharp]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) UriDecode(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.uri_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the C language standard.
*/
//go:nosplit
func (self StringName) CEscape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.c_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\"[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence.
*/
//go:nosplit
func (self StringName) CUnescape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.c_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary.
*/
//go:nosplit
func (self StringName) JsonEscape(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.json_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]"[/code] [code]%[/code]) replaced with underscores.
*/
//go:nosplit
func (self StringName) ValidateNodeName(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.validate_node_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores.
*/
//go:nosplit
func (self StringName) ValidateFilename(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.validate_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print("node_2d".is_valid_identifier())    # Prints true
print("TYPE_FLOAT".is_valid_identifier()) # Prints true
print("1st_method".is_valid_identifier()) # Prints false
print("MyMethod#2".is_valid_identifier()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidIdentifier() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_identifier(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print("7".is_valid_int())    # Prints true
print("1.65".is_valid_int()) # Prints false
print("Hi".is_valid_int())   # Prints false
print("+3".is_valid_int())   # Prints true
print("-12".is_valid_int())  # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidInt() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print("1.7".is_valid_float())   # Prints true
print("24".is_valid_float())    # Prints true
print("7e3".is_valid_float())   # Prints true
print("Hello".is_valid_float()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidFloat() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]"0x"[/code] to be considered valid.
[codeblock]
print("A08E".is_valid_hex_number())    # Prints true
print("-AbCdEf".is_valid_hex_number()) # Prints true
print("2.5".is_valid_hex_number())     # Prints false

print("0xDEADC0DE".is_valid_hex_number(true)) # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidHexNumber(with_prefix bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, with_prefix)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_hex_number(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html].
*/
//go:nosplit
func (self StringName) IsValidHtmlColor() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_html_color(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]"0.0.0.0"[/code] and [code]"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"[/code] as valid.
*/
//go:nosplit
func (self StringName) IsValidIpAddress() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_ip_address(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code]*[/code] [code]"[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]).
*/
//go:nosplit
func (self StringName) IsValidFilename() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.is_valid_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = "123".to_int()    # a is 123
var b = "x1y2z3".to_int() # b is 123
var c = "-1.2.3".to_int() # c is -1
var d = "Hello!".to_int() # d is 0
[/codeblock]
*/
//go:nosplit
func (self StringName) ToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = "12.35".to_float() # a is 12.35
var b = "1.2.3".to_float() # b is 1.2
var c = "12xy3".to_float() # c is 12.0
var d = "1e3".to_float()   # d is 1000.0
var e = "Hello!".to_int()  # e is 0.0
[/codeblock]
*/
//go:nosplit
func (self StringName) ToFloat() Float {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]"0x"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("0xff".hex_to_int()) # Prints 255
print("ab".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print("0xff".HexToInt()); // Prints 255
GD.Print("ab".HexToInt());   // Prints 171
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) HexToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.hex_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]"0b"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("101".bin_to_int())   # Prints 5
print("0b101".bin_to_int()) # Prints 5
print("-0b10".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print("101".BinToInt());   // Prints 5
GD.Print("0b101".BinToInt()); // Prints 5
GD.Print("-0b10".BinToInt()); // Prints -2
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) BinToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.bin_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad].
*/
//go:nosplit
func (self StringName) Lpad(ctx Context, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.lpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad].
*/
//go:nosplit
func (self StringName) Rpad(ctx Context, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.rpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point.
*/
//go:nosplit
func (self StringName) PadDecimals(ctx Context, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.pad_decimals(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point.
*/
//go:nosplit
func (self StringName) PadZeros(ctx Context, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.pad_zeros(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes the given [param prefix] from the start of the string, or returns the string unchanged.
*/
//go:nosplit
func (self StringName) TrimPrefix(ctx Context, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.trim_prefix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes the given [param suffix] from the end of the string, or returns the string unchanged.
*/
//go:nosplit
func (self StringName) TrimSuffix(ctx Context, suffix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(suffix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.trim_suffix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces.
*/
//go:nosplit
func (self StringName) ToAsciiBuffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_ascii_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method.
*/
//go:nosplit
func (self StringName) ToUtf8Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_utf8_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToUtf16Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_utf16_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToUtf32Buffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_utf32_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # outputs "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) HexDecode(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.hex_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToWcharBuffer(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.to_wchar_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self StringName) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.StringName.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the node path is absolute (as opposed to relative), which means that it starts with a slash character ([code]/[/code]). Absolute node paths can be used to access the root node ([code]"/root"[/code]) or autoloads (e.g. [code]"/global"[/code] if a "global" autoload was registered).
*/
//go:nosplit
func (self NodePath) IsAbsolute() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.is_absolute(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of node names which make up the path. Subnames (see [method get_subname_count]) are not included.
For example, [code]"Path2D/PathFollow2D/Sprite2D"[/code] has 3 names.
*/
//go:nosplit
func (self NodePath) GetNameCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_name_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the node name indicated by [param idx] (0 to [method get_name_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath("Path2D/PathFollow2D/Sprite2D")
print(node_path.get_name(0)) # Path2D
print(node_path.get_name(1)) # PathFollow2D
print(node_path.get_name(2)) # Sprite
[/gdscript]
[csharp]
var nodePath = new NodePath("Path2D/PathFollow2D/Sprite2D");
GD.Print(nodePath.GetName(0)); // Path2D
GD.Print(nodePath.GetName(1)); // PathFollow2D
GD.Print(nodePath.GetName(2)); // Sprite
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetName(ctx Context, idx Int) StringName {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Gets the number of resource or property names ("subnames") in the path. Each subname is listed after a colon character ([code]:[/code]) in the node path.
For example, [code]"Path2D/PathFollow2D/Sprite2D:texture:load_path"[/code] has 2 subnames.
*/
//go:nosplit
func (self NodePath) GetSubnameCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_subname_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the 32-bit hash value representing the [NodePath]'s contents.
*/
//go:nosplit
func (self NodePath) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the resource or property name indicated by [param idx] (0 to [method get_subname_count] - 1).
[codeblocks]
[gdscript]
var node_path = NodePath("Path2D/PathFollow2D/Sprite2D:texture:load_path")
print(node_path.get_subname(0)) # texture
print(node_path.get_subname(1)) # load_path
[/gdscript]
[csharp]
var nodePath = new NodePath("Path2D/PathFollow2D/Sprite2D:texture:load_path");
GD.Print(nodePath.GetSubname(0)); // texture
GD.Print(nodePath.GetSubname(1)); // load_path
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetSubname(ctx Context, idx Int) StringName {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_subname(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns all paths concatenated with a slash character ([code]/[/code]) as separator without subnames.
*/
//go:nosplit
func (self NodePath) GetConcatenatedNames(ctx Context) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_concatenated_names(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns all subnames concatenated with a colon character ([code]:[/code]) as separator, i.e. the right side of the first colon in a node path.
[codeblocks]
[gdscript]
var node_path = NodePath("Path2D/PathFollow2D/Sprite2D:texture:load_path")
print(node_path.get_concatenated_subnames()) # texture:load_path
[/gdscript]
[csharp]
var nodePath = new NodePath("Path2D/PathFollow2D/Sprite2D:texture:load_path");
GD.Print(nodePath.GetConcatenatedSubnames()); // texture:load_path
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetConcatenatedSubnames(ctx Context) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_concatenated_subnames(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a node path with a colon character ([code]:[/code]) prepended, transforming it to a pure property path with no node name (defaults to resolving from the current node).
[codeblocks]
[gdscript]
# This will be parsed as a node path to the "x" property in the "position" node.
var node_path = NodePath("position:x")
# This will be parsed as a node path to the "x" component of the "position" property in the current node.
var property_path = node_path.get_as_property_path()
print(property_path) # :position:x
[/gdscript]
[csharp]
// This will be parsed as a node path to the "x" property in the "position" node.
var nodePath = new NodePath("position:x");
// This will be parsed as a node path to the "x" component of the "position" property in the current node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // :position:x
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetAsPropertyPath(ctx Context) NodePath {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.get_as_property_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[NodePath](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the node path is empty.
*/
//go:nosplit
func (self NodePath) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.NodePath.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Calls the method represented by this [Callable]. Unlike [method call], this method expects all arguments to be contained inside the [param arguments] [Array].
*/
//go:nosplit
func (self Callable) Callv(ctx Context, arguments Array) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.callv(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this [Callable] has no target to call the method on.
*/
//go:nosplit
func (self Callable) IsNull() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.is_null(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this [Callable] is a custom callable. Custom callables are created from [method bind] or [method unbind]. In GDScript, lambda functions are also custom callables.
*/
//go:nosplit
func (self Callable) IsCustom() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.is_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this [Callable] is a standard callable. This method is the opposite of [method is_custom]. Returns [code]false[/code] if this callable is a lambda function.
*/
//go:nosplit
func (self Callable) IsStandard() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.is_standard(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the callable's object exists and has a valid method name assigned, or is a custom callable.
*/
//go:nosplit
func (self Callable) IsValid() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.is_valid(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the object on which this [Callable] is called.
*/
//go:nosplit
func (self Callable) GetObject(ctx Context) Object {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.get_object(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret Object
	ret.SetPointer(PointerWithOwnershipTransferredToGo(ctx, r_ret.Get()))
	frame.Free()
	return ret
}

/*
Returns the ID of this [Callable]'s object (see [method Object.get_instance_id]).
*/
//go:nosplit
func (self Callable) GetObjectId() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.get_object_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the name of the method represented by this [Callable]. If the callable is a GDScript lambda function, returns the function's name or [code]"<anonymous lambda>"[/code].
*/
//go:nosplit
func (self Callable) GetMethod(ctx Context) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.get_method(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the total amount of arguments bound (or unbound) via successive [method bind] or [method unbind] calls. If the amount of arguments unbound is greater than the ones bound, this function returns a value less than zero.
*/
//go:nosplit
func (self Callable) GetBoundArgumentsCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.get_bound_arguments_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Return the bound arguments (as long as [method get_bound_arguments_count] is greater than zero), or empty (if [method get_bound_arguments_count] is less than or equal to zero).
*/
//go:nosplit
func (self Callable) GetBoundArguments(ctx Context) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.get_bound_arguments(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the 32-bit hash value of this [Callable]'s object.
[b]Note:[/b] [Callable]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for [method hash].
*/
//go:nosplit
func (self Callable) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a copy of this [Callable] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
*/
//go:nosplit
func (self Callable) Bindv(ctx Context, arguments Array) Callable {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.bindv(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of this [Callable] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to [param argcount]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also [method bind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
[codeblock]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
[/codeblock]
*/
//go:nosplit
func (self Callable) Unbind(ctx Context, argcount Int) Callable {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, argcount)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.unbind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the method represented by this [Callable]. Arguments can be passed and should match the method's signature.
*/
//go:nosplit
func (self Callable) Call(ctx Context, args ...Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.call(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the method represented by this [Callable] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method's signature.
[codeblock]
func _ready():
    grab_focus.call_deferred()
[/codeblock]
[b]Note:[/b] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also [method Object.call_deferred].
*/
//go:nosplit
func (self Callable) CallDeferred(args ...Variant) {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.call_deferred(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}

/*
Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc].
*/
//go:nosplit
func (self Callable) Rpc(args ...Variant) {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.rpc(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}

/*
Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc_id].
*/
//go:nosplit
func (self Callable) RpcId(peer_id Int, args ...Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, peer_id)
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.rpc_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+1)
	frame.Free()
}

/*
Returns a copy of this [Callable] with one or more arguments bound. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
*/
//go:nosplit
func (self Callable) Bind(ctx Context, args ...Variant) Callable {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Callable.bind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the signal's name does not exist in its object, or the object is not valid.
*/
//go:nosplit
func (self Signal) IsNull() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.is_null(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the object emitting this signal.
*/
//go:nosplit
func (self Signal) GetObject(ctx Context) Object {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.get_object(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret Object
	ret.SetPointer(PointerWithOwnershipTransferredToGo(ctx, r_ret.Get()))
	frame.Free()
	return ret
}

/*
Returns the ID of the object emitting this signal (see [method Object.get_instance_id]).
*/
//go:nosplit
func (self Signal) GetObjectId() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.get_object_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the name of this signal.
*/
//go:nosplit
func (self Signal) GetName(ctx Context) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.get_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Connects this signal to the specified [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum Object.ConnectFlags] constants). You can provide additional arguments to the connected [param callable] by using [method Callable.bind].
A signal can only be connected once to the same [Callable]. If the signal is already connected, returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant Object.CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
[codeblock]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, " was pressed")
[/codeblock]
*/
//go:nosplit
func (self Signal) Connect(callable Callable, flags Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.connect(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Disconnects this signal from the specified [Callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists.
*/
//go:nosplit
func (self Signal) Disconnect(callable Callable) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.disconnect(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Returns [code]true[/code] if the specified [Callable] is connected to this signal.
*/
//go:nosplit
func (self Signal) IsConnected(callable Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.is_connected(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an [Array] of connections for this signal. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to this signal;
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum Object.ConnectFlags].
*/
//go:nosplit
func (self Signal) GetConnections(ctx Context) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.get_connections(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Emits this signal. All [Callable]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
*/
//go:nosplit
func (self Signal) Emit(args ...Variant) {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Signal.emit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}

/*
Returns the number of entries in the dictionary. Empty dictionaries ([code]{ }[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self Dictionary) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the dictionary is empty (its size is [code]0[/code]). See also [method size].
*/
//go:nosplit
func (self Dictionary) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the dictionary, removing all entries from it.
*/
//go:nosplit
func (self Dictionary) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Adds entries from [param dictionary] to this dictionary. By default, duplicate keys are not copied over, unless [param overwrite] is [code]true[/code].
[codeblocks]
[gdscript]
var dict = { "item": "sword", "quantity": 2 }
var other_dict = { "quantity": 15, "color": "silver" }

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # { "item": "sword", "quantity": 2, "color": "silver" }

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # { "item": "sword", "quantity": 15, "color": "silver" }
[/gdscript]
[csharp]
var dict = new Godot.Collections.Dictionary
{
    ["item"] = "sword",
    ["quantity"] = 2,
};

var otherDict = new Godot.Collections.Dictionary
{
    ["quantity"] = 15,
    ["color"] = "silver",
};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // { "item": "sword", "quantity": 2, "color": "silver" }

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // { "item": "sword", "quantity": 15, "color": "silver" }
[/csharp]
[/codeblocks]
[b]Note:[/b] [method merge] is [i]not[/i] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of [param overwrite], but they will never be merged together.
*/
//go:nosplit
func (self Dictionary) Merge(dictionary Dictionary, overwrite bool) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(dictionary))
	callframe.Arg(frame, overwrite)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.merge(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Returns [code]true[/code] if the dictionary contains an entry with the given [param key].
[codeblocks]
[gdscript]
var my_dict = {
    "Godot" : 4,
    210 : null,
}

print(my_dict.has("Godot")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
[/gdscript]
[csharp]
var myDict = new Godot.Collections.Dictionary
{
    { "Godot", 4 },
    { 210, default },
};

GD.Print(myDict.ContainsKey("Godot")); // Prints true
GD.Print(myDict.ContainsKey(210));     // Prints true
GD.Print(myDict.ContainsKey(4));       // Prints false
[/csharp]
[/codeblocks]
In GDScript, this is equivalent to the [code]in[/code] operator:
[codeblock]
if "Godot" in {"Godot": 4}:
    print("The key is here!") # Will be printed.
[/codeblock]
[b]Note:[/b] This method returns [code]true[/code] as long as the [param key] exists, even if its corresponding value is [code]null[/code].
*/
//go:nosplit
func (self Dictionary) Has(key Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the dictionary contains all keys in the given [param keys] array.
[codeblock]
var data = {"width" : 10, "height" : 20}
data.has_all(["height", "width"]) # Returns true
[/codeblock]
*/
//go:nosplit
func (self Dictionary) HasAll(keys Array) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(keys))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.has_all(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Finds and returns the first key whose associated value is equal to [param value], or [code]null[/code] if it is not found.
[b]Note:[/b] [code]null[/code] is also a valid key. If inside the dictionary, [method find_key] may give misleading results.
*/
//go:nosplit
func (self Dictionary) FindKey(ctx Context, value Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.find_key(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes the dictionary entry by key, if it exists. Returns [code]true[/code] if the given [param key] existed in the dictionary, otherwise [code]false[/code].
[b]Note:[/b] Do not erase entries while iterating over the dictionary. You can iterate over the [method keys] array instead.
*/
//go:nosplit
func (self Dictionary) Erase(key Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a hashed 32-bit integer value representing the dictionary contents.
[codeblocks]
[gdscript]
var dict1 = {"A": 10, "B": 2}
var dict2 = {"A": 10, "B": 2}

print(dict1.hash() == dict2.hash()) # Prints true
[/gdscript]
[csharp]
var dict1 = new Godot.Collections.Dictionary{{"A", 10}, {"B", 2}};
var dict2 = new Godot.Collections.Dictionary{{"A", 10}, {"B", 2}};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints true
[/csharp]
[/codeblocks]
[b]Note:[/b] Dictionaries with the same entries but in a different order will not have the same hash.
[b]Note:[/b] Dictionaries with equal hash values are [i]not[/i] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self Dictionary) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the list of keys in the dictionary.
*/
//go:nosplit
func (self Dictionary) Keys(ctx Context) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.keys(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the list of values in this dictionary.
*/
//go:nosplit
func (self Dictionary) Values(ctx Context) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.values(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Creates and returns a new copy of the dictionary. If [param deep] is [code]true[/code], inner [Dictionary] and [Array] keys and values are also copied, recursively.
*/
//go:nosplit
func (self Dictionary) Duplicate(ctx Context, deep bool) Dictionary {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Dictionary](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the corresponding value for the given [param key] in the dictionary. If the [param key] does not exist, returns [param default], or [code]null[/code] if the parameter is omitted.
*/
//go:nosplit
func (self Dictionary) Get(ctx Context, key Variant, def Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	callframe.Arg(frame, mmm.Get(def))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.get(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries.
*/
//go:nosplit
func (self Dictionary) MakeReadOnly() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.make_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the dictionary is read-only. See [method make_read_only]. Dictionaries are automatically read-only if declared with [code]const[/code] keyword.
*/
//go:nosplit
func (self Dictionary) IsReadOnly() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Dictionary.is_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns a hashed 32-bit integer value representing the array and its contents.
[b]Note:[/b] [Array]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the arrays are equal, because different arrays can have identical hash values due to hash collisions.
*/
//go:nosplit
func (self Array) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns elements of another [param array] into the array. Resizes the array to match [param array]. Performs type conversions if the array is typed.
*/
//go:nosplit
func (self Array) Assign(array Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.assign(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Appends an element at the end of the array. See also [method push_front].
*/
//go:nosplit
func (self Array) PushBack(value Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Adds an element at the beginning of the array. See also [method push_back].
[b]Note:[/b] On large arrays, this method is much slower than [method push_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method push_front] will be.
*/
//go:nosplit
func (self Array) PushFront(value Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.push_front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self Array) Append(value Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Appends another array at the end of this array.
[codeblock]
var array1 = [1, 2, 3]
var array2 = [4, 5, 6]
array1.append_array(array2)
print(array1) # Prints [1, 2, 3, 4, 5, 6].
[/codeblock]
*/
//go:nosplit
func (self Array) AppendArray(array Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Resizes the array to contain a different number of elements. If the array size is smaller, elements are cleared, if bigger, new elements are [code]null[/code]. Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
*/
//go:nosplit
func (self Array) Resize(size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]pos == size()[/code]). Returns [constant OK] on success, or one of the other [enum Error] values if the operation failed.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the inserted element is close to the beginning of the array (index 0). This is because all elements placed after the newly inserted element have to be reindexed.
*/
//go:nosplit
func (self Array) Insert(position Int, value Variant) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes an element from the array by index. If the index does not exist in the array, nothing happens. To remove an element by searching for its value, use [method erase] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] [param position] cannot be negative. To remove an element relative to the end of the array, use [code]arr.remove_at(arr.size() - (i + 1))[/code]. To remove the last element from the array without returning the value, use [code]arr.resize(arr.size() - 1)[/code].
*/
//go:nosplit
func (self Array) RemoveAt(position Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements:
[codeblocks]
[gdscript]
var array = []
array.resize(10)
array.fill(0) # Initialize the 10 elements to 0.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array();
array.Resize(10);
array.Fill(0); // Initialize the 10 elements to 0.
[/csharp]
[/codeblocks]
[b]Note:[/b] If [param value] is of a reference type ([Object]-derived, [Array], [Dictionary], etc.) then the array is filled with the references to the same object, i.e. no duplicates are created.
*/
//go:nosplit
func (self Array) Fill(value Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes the first occurrence of a value from the array. If the value does not exist in the array, nothing happens. To remove an element by index, use [method remove_at] instead.
[b]Note:[/b] This method acts in-place and doesn't return a modified array.
[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
[b]Note:[/b] Do not erase entries while iterating over the array.
*/
//go:nosplit
func (self Array) Erase(value Variant) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Returns the first element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[0][/code]. If the array is empty, accessing by index will pause project execution when running from the editor.
*/
//go:nosplit
func (self Array) Front(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the last element of the array. Prints an error and returns [code]null[/code] if the array is empty.
[b]Note:[/b] Calling this function is not the same as writing [code]array[-1][/code]. If the array is empty, accessing by index will pause project execution when running from the editor.
*/
//go:nosplit
func (self Array) Back(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a random value from the target array. Prints an error and returns [code]null[/code] if the array is empty.
[codeblocks]
[gdscript]
var array: Array[int] = [1, 2, 3, 4]
print(array.pick_random())  # Prints either of the four numbers.
[/gdscript]
[csharp]
var array = new Godot.Collections.Array { 1, 2, 3, 4 };
GD.Print(array.PickRandom()); // Prints either of the four numbers.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Array) PickRandom(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.pick_random(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self Array) Find(what Variant, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self Array) Rfind(what Variant, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self Array) Count(value Variant) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array contains the given value.
[codeblocks]
[gdscript]
print(["inside", 7].has("inside")) # True
print(["inside", 7].has("outside")) # False
print(["inside", 7].has(7)) # True
print(["inside", 7].has("7")) # False
[/gdscript]
[csharp]
var arr = new Godot.Collections.Array { "inside", 7 };
// has is renamed to Contains
GD.Print(arr.Contains("inside")); // True
GD.Print(arr.Contains("outside")); // False
GD.Print(arr.Contains(7)); // True
GD.Print(arr.Contains("7")); // False
[/csharp]
[/codeblocks]
[b]Note:[/b] This is equivalent to using the [code]in[/code] operator as follows:
[codeblocks]
[gdscript]
# Will evaluate to `true`.
if 2 in [2, 4, 6, 8]:
    print("Contains!")
[/gdscript]
[csharp]
// As there is no "in" keyword in C#, you have to use Contains
var array = new Godot.Collections.Array { 2, 4, 6, 8 };
if (array.Contains(2))
{
    GD.Print("Contains!");
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Array) Has(value Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes and returns the last element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_front].
*/
//go:nosplit
func (self Array) PopBack(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.pop_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes and returns the first element of the array. Returns [code]null[/code] if the array is empty, without printing an error message. See also [method pop_back].
[b]Note:[/b] On large arrays, this method is much slower than [method pop_back] as it will reindex all the array's elements every time it's called. The larger the array, the slower [method pop_front] will be.
*/
//go:nosplit
func (self Array) PopFront(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.pop_front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Removes and returns the element of the array at index [param position]. If negative, [param position] is considered relative to the end of the array. Leaves the array unchanged and returns [code]null[/code] if the array is empty or if it's accessed out of bounds. An error message is printed when the array is accessed out of bounds, but not when the array is empty.
[b]Note:[/b] On large arrays, this method can be slower than [method pop_back] as it will reindex the array's elements that are located after the removed element. The larger the array and the lower the index of the removed element, the slower [method pop_at] will be.
*/
//go:nosplit
func (self Array) PopAt(ctx Context, position Int) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.pop_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort].
[b]Note:[/b] Strings are sorted in alphabetical order (as opposed to natural order). This may lead to unexpected behavior when sorting an array of strings ending with a sequence of numbers. Consider the following example:
[codeblocks]
[gdscript]
var strings = ["string1", "string2", "string10", "string11"]
strings.sort()
print(strings) # Prints [string1, string10, string11, string2]
[/gdscript]
[csharp]
var strings = new Godot.Collections.Array { "string1", "string2", "string10", "string11" };
strings.Sort();
GD.Print(strings); // Prints [string1, string10, string11, string2]
[/csharp]
[/codeblocks]
To perform natural order sorting, you can use [method sort_custom] with [method String.naturalnocasecmp_to] as follows:
[codeblock]
var strings = ["string1", "string2", "string10", "string11"]
strings.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(strings) # Prints [string1, string2, string10, string11]
[/codeblock]
*/
//go:nosplit
func (self Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Sorts the array using a custom method. The custom method receives two arguments (a pair of elements from the array) and must return either [code]true[/code] or [code]false[/code]. For two elements [code]a[/code] and [code]b[/code], if the given method returns [code]true[/code], element [code]b[/code] will be after element [code]a[/code] in the array.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when using [method sort_custom].
[b]Note:[/b] You cannot randomize the return value as the heapsort algorithm expects a deterministic result. Randomizing the return value will result in unexpected behavior.
[codeblocks]
[gdscript]
func sort_ascending(a, b):
    if a[0] < b[0]:
        return true
    return false

func _ready():
    var my_items = [[5, "Potato"], [9, "Rice"], [4, "Tomato"]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints [[4, Tomato], [5, Potato], [9, Rice]].

    # Descending, lambda version.
    my_items.sort_custom(func(a, b): return a[0] > b[0])
    print(my_items) # Prints [[9, Rice], [5, Potato], [4, Tomato]].
[/gdscript]
[csharp]
// There is no custom sort support for Godot.Collections.Array
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Array) SortCustom(fn Callable) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(fn))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.sort_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Shuffles the array such that the items will have a random order. This method uses the global random number generator common to methods such as [method @GlobalScope.randi]. Call [method @GlobalScope.randomize] to ensure that a new seed will be used each time if you want non-reproducible shuffling.
*/
//go:nosplit
func (self Array) Shuffle() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.shuffle(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[codeblock]
var array = ["a", "b", "c", "c", "d", "e"]
print(array.bsearch("c", true))  # Prints 2, at the first matching element.
print(array.bsearch("c", false)) # Prints 4, after the last matching element, pointing to "d".
[/codeblock]
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self Array) Bsearch(value Variant, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search and a custom comparison method. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array. The custom method receives two arguments (an element from the array and the value searched for) and must return [code]true[/code] if the first argument is less than the second, and return [code]false[/code] otherwise.
[b]Note:[/b] The custom method must accept the two arguments in any order, you cannot rely on that the first argument will always be from the array.
[b]Note:[/b] Calling [method bsearch_custom] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self Array) BsearchCustom(value Variant, fn Callable, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(fn))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.bsearch_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns a copy of the array.
If [param deep] is [code]true[/code], a deep copy is performed: all nested arrays and dictionaries are duplicated and will not be shared with the original array. If [code]false[/code], a shallow copy is made and references to the original nested arrays and dictionaries are kept, so that modifying a sub-array or dictionary in the copy will also impact those referenced in the source array. Note that any [Object]-derived elements will be shallow copied regardless of the [param deep] setting.
*/
//go:nosplit
func (self Array) Duplicate(ctx Context, deep bool) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the slice of the [Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
If specified, [param step] is the relative index between source elements. It can be negative, then [param begin] must be higher than [param end]. For example, [code][0, 1, 2, 3, 4, 5].slice(5, 1, -2)[/code] returns [code][5, 3][/code].
If [param deep] is true, each element will be copied by value rather than by reference.
[b]Note:[/b] To include the first element when [param step] is negative, use [code]arr.slice(begin, -arr.size() - 1, step)[/code] (i.e. [code][0, 1, 2].slice(1, -4, -1)[/code] returns [code][1, 0][/code]).
*/
//go:nosplit
func (self Array) Slice(ctx Context, begin Int, end Int, step Int, deep bool) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	callframe.Arg(frame, step)
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 4)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the provided [Callable] on each element in the array and returns a new array with the elements for which the method returned [code]true[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([1, 2, 3].filter(remove_1)) # Prints [2, 3].
    print([1, 2, 3].filter(func(number): return number != 1)) # Same as above, but using lambda function.

func remove_1(number):
    return number != 1
[/codeblock]
See also [method any], [method all], [method map] and [method reduce].
*/
//go:nosplit
func (self Array) Filter(ctx Context, method Callable) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.filter(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the provided [Callable] for each element in the array and returns a new array filled with values returned by the method.
The callable's method should take one [Variant] parameter (the current array element) and can return any [Variant].
[codeblock]
func _ready():
    print([1, 2, 3].map(negate)) # Prints [-1, -2, -3].
    print([1, 2, 3].map(func(number): return -number)) # Same as above, but using lambda function.

func negate(number):
    return -number
[/codeblock]
See also [method filter], [method reduce], [method any] and [method all].
*/
//go:nosplit
func (self Array) Map(ctx Context, method Callable) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.map_(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the provided [Callable] for each element in array and accumulates the result in [param accum].
The callable's method takes two arguments: the current value of [param accum] and the current array element. If [param accum] is [code]null[/code] (default value), the iteration will start from the second element, with the first one used as initial value of [param accum].
[codeblock]
func _ready():
    print([1, 2, 3].reduce(sum, 10)) # Prints 16.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10)) # Same as above, but using lambda function.

func sum(accum, number):
    return accum + number
[/codeblock]
See also [method map], [method filter], [method any] and [method all].
*/
//go:nosplit
func (self Array) Reduce(ctx Context, method Callable, accum Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	callframe.Arg(frame, mmm.Get(accum))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.reduce(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]one or more[/i] elements in the array. If the [Callable] returns [code]false[/code] for all elements in the array, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].any(greater_than_5))  # Prints True (3 elements evaluate to `true`).
    print([4, 10, 4].any(greater_than_5))  # Prints True (1 elements evaluate to `true`).
    print([4, 4, 4].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).
    print([].any(greater_than_5))  # Prints False (0 elements evaluate to `true`).

    print([6, 10, 6].any(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method all], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method always returns [code]false[/code].
*/
//go:nosplit
func (self Array) Any(method Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.any(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Calls the provided [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]all[/i] elements in the array. If the [Callable] returns [code]false[/code] for one array element or more, this method returns [code]false[/code].
The callable's method should take one [Variant] parameter (the current array element) and return a boolean value.
[codeblock]
func _ready():
    print([6, 10, 6].all(greater_than_5))  # Prints True (3/3 elements evaluate to `true`).
    print([4, 10, 4].all(greater_than_5))  # Prints False (1/3 elements evaluate to `true`).
    print([4, 4, 4].all(greater_than_5))  # Prints False (0/3 elements evaluate to `true`).
    print([].all(greater_than_5))  # Prints True (0/0 elements evaluate to `true`).

    print([6, 10, 6].all(func(number): return number > 5))  # Prints True. Same as the first line above, but using lambda function.

func greater_than_5(number):
    return number > 5
[/codeblock]
See also [method any], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method [url=https://en.wikipedia.org/wiki/Vacuous_truth]always[/url] returns [code]true[/code].
*/
//go:nosplit
func (self Array) All(method Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.all(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the maximum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
To find the maximum value using a custom comparator, you can use [method reduce]. In this example every array element is checked and the first maximum value is returned:
[codeblock]
func _ready():
    var arr = [Vector2(0, 1), Vector2(2, 0), Vector2(1, 1), Vector2(1, 0), Vector2(0, 2)]
    # In this example we compare the lengths.
    print(arr.reduce(func(max, val): return val if is_length_greater(val, max) else max))

func is_length_greater(a, b):
    return a.length() > b.length()
[/codeblock]
*/
//go:nosplit
func (self Array) Max(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.max(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the minimum value contained in the array if all elements are of comparable types. If the elements can't be compared, [code]null[/code] is returned.
See also [method max] for an example of using a custom comparator.
*/
//go:nosplit
func (self Array) Min(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.min(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is typed. Typed arrays can only store elements of their associated type and provide type safety for the [code][][/code] operator. Methods of typed array still return [Variant].
*/
//go:nosplit
func (self Array) IsTyped() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.is_typed(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is typed the same as [param array].
*/
//go:nosplit
func (self Array) IsSameTyped(array Array) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.is_same_typed(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the built-in type of the typed array as a [enum Variant.Type] constant. If the array is not typed, returns [constant TYPE_NIL].
*/
//go:nosplit
func (self Array) GetTypedBuiltin() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.get_typed_builtin(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the [b]native[/b] class name of the typed array if the built-in type is [constant TYPE_OBJECT]. Otherwise, this method returns an empty string.
*/
//go:nosplit
func (self Array) GetTypedClassName(ctx Context) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.get_typed_class_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the script associated with the typed array. This method returns a [Script] instance or [code]null[/code].
*/
//go:nosplit
func (self Array) GetTypedScript(ctx Context) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.get_typed_script(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Makes the array read-only, i.e. disabled modifying of the array's elements. Does not apply to nested content, e.g. content of nested arrays.
*/
//go:nosplit
func (self Array) MakeReadOnly() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.make_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array is read-only. See [method make_read_only]. Arrays are automatically read-only if declared with [code]const[/code] keyword.
*/
//go:nosplit
func (self Array) IsReadOnly() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.Array.is_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedByteArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedByteArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the byte at the given index.
*/
//go:nosplit
func (self PackedByteArray) Set(index Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self PackedByteArray) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedByteArray) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedByteArray] at the end of this array.
*/
//go:nosplit
func (self PackedByteArray) AppendArray(array PackedByteArray) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedByteArray) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedByteArray) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedByteArray) Fill(value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedByteArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedByteArray) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self PackedByteArray) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedByteArray) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedByteArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedByteArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedByteArray) Slice(ctx Context, begin Int, end Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self PackedByteArray) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self PackedByteArray) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedByteArray) Duplicate(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self PackedByteArray) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self PackedByteArray) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self PackedByteArray) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Converts ASCII/Latin-1 encoded array to [String]. Fast alternative to [method get_string_from_utf8] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use [method get_string_from_utf8]. This is the inverse of [method String.to_ascii_buffer].
*/
//go:nosplit
func (self PackedByteArray) GetStringFromAscii(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.get_string_from_ascii(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts UTF-8 encoded array to [String]. Slower than [method get_string_from_ascii] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of [method String.to_utf8_buffer].
*/
//go:nosplit
func (self PackedByteArray) GetStringFromUtf8(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.get_string_from_utf8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts UTF-16 encoded array to [String]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of [method String.to_utf16_buffer].
*/
//go:nosplit
func (self PackedByteArray) GetStringFromUtf16(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.get_string_from_utf16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts UTF-32 encoded array to [String]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of [method String.to_utf32_buffer].
*/
//go:nosplit
func (self PackedByteArray) GetStringFromUtf32(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.get_string_from_utf32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Converts wide character ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded array to [String]. Returns empty string if source array is not valid wide string. This is the inverse of [method String.to_wchar_buffer].
*/
//go:nosplit
func (self PackedByteArray) GetStringFromWchar(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.get_string_from_wchar(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a hexadecimal representation of this array as a [String].
[codeblocks]
[gdscript]
var array = PackedByteArray([11, 46, 255])
print(array.hex_encode()) # Prints: 0b2eff
[/gdscript]
[csharp]
var array = new byte[] {11, 46, 255};
GD.Print(array.HexEncode()); // Prints: 0b2eff
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self PackedByteArray) HexEncode(ctx Context) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.hex_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a new [PackedByteArray] with the data compressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
*/
//go:nosplit
func (self PackedByteArray) Compress(ctx Context, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.compress(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a new [PackedByteArray] with the data decompressed. Set [param buffer_size] to the size of the uncompressed data. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header.
*/
//go:nosplit
func (self PackedByteArray) Decompress(ctx Context, buffer_size Int, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, buffer_size)
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decompress(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a new [PackedByteArray] with the data decompressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. [b]This method only accepts brotli, gzip, and deflate compression modes.[/b]
This method is potentially slower than [method decompress], as it may have to re-allocate its output buffer multiple times while decompressing, whereas [method decompress] knows it's output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it's very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via [param max_output_size]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header.
*/
//go:nosplit
func (self PackedByteArray) DecompressDynamic(ctx Context, max_output_size Int, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, max_output_size)
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decompress_dynamic(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes a 8-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeU8(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_u8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 8-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeS8(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_s8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 16-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeU16(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_u16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 16-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeS16(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_s16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 32-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeU32(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_u32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 32-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeS32(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_s32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 64-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeU64(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_u64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 64-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeS64(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_s64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 16-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeHalf(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_half(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 32-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeFloat(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a 64-bit floating point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self PackedByteArray) DecodeDouble(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_double(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if a valid [Variant] value can be decoded at the [param byte_offset]. Returns [code]false[/code] otherwise or when the value is [Object]-derived and [param allow_objects] is [code]false[/code].
*/
//go:nosplit
func (self PackedByteArray) HasEncodedVar(byte_offset Int, allow_objects bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.has_encoded_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decodes a [Variant] from the bytes starting at [param byte_offset]. Returns [code]null[/code] if a valid variant can't be decoded or the value is [Object]-derived and [param allow_objects] is [code]false[/code].
*/
//go:nosplit
func (self PackedByteArray) DecodeVar(ctx Context, byte_offset Int, allow_objects bool) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Decodes a size of a [Variant] from the bytes starting at [param byte_offset]. Requires at least 4 bytes of data starting at the offset, otherwise fails.
*/
//go:nosplit
func (self PackedByteArray) DecodeVarSize(byte_offset Int, allow_objects bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.decode_var_size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedInt32Array], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ [code]int32_t[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to signed 32-bit integers, the resulting data is undefined.
*/
//go:nosplit
func (self PackedByteArray) ToInt32Array(ctx Context) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.to_int32_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedInt64Array], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ [code]int64_t[/code], Godot [int]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to signed 64-bit integers, the resulting data is undefined.
*/
//go:nosplit
func (self PackedByteArray) ToInt64Array(ctx Context) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.to_int64_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedFloat32Array], where each block of 4 bytes has been converted to a 32-bit float (C++ [code skip-lint]float[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to 32-bit floats, the resulting data is undefined.
*/
//go:nosplit
func (self PackedByteArray) ToFloat32Array(ctx Context) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.to_float32_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedFloat64Array], where each block of 8 bytes has been converted to a 64-bit float (C++ [code]double[/code], Godot [float]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to 64-bit floats, the resulting data is undefined.
*/
//go:nosplit
func (self PackedByteArray) ToFloat64Array(ctx Context) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.to_float64_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Encodes a 8-bit unsigned integer number (byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeU8(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_u8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 8-bit signed integer number (signed byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeS8(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_s8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 16-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeU16(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_u16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 16-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeS16(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_s16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 32-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeU32(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_u32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 32-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeS32(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_s32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 64-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeU64(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_u64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 64-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeS64(byte_offset Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_s64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 16-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeHalf(byte_offset Int, value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_half(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 32-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeFloat(byte_offset Int, value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a 64-bit floating point number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of allocated space, starting at the offset.
*/
//go:nosplit
func (self PackedByteArray) EncodeDouble(byte_offset Int, value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_double(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Encodes a [Variant] at the index of [param byte_offset] bytes. A sufficient space must be allocated, depending on the encoded variant's size. If [param allow_objects] is [code]false[/code], [Object]-derived values are not permitted and will instead be serialized as ID-only.
*/
//go:nosplit
func (self PackedByteArray) EncodeVar(byte_offset Int, value Variant, allow_objects bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedByteArray.encode_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedInt32Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedInt32Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the integer at the given index.
*/
//go:nosplit
func (self PackedInt32Array) Set(index Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends a value to the array.
*/
//go:nosplit
func (self PackedInt32Array) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedInt32Array) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedInt32Array] at the end of this array.
*/
//go:nosplit
func (self PackedInt32Array) AppendArray(array PackedInt32Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedInt32Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedInt32Array) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedInt32Array) Fill(value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedInt32Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedInt32Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self PackedInt32Array) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedInt32Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedInt32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedInt32Array) Slice(ctx Context, begin Int, end Int) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]int32_array.size() * 4[/code].
*/
//go:nosplit
func (self PackedInt32Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self PackedInt32Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self PackedInt32Array) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedInt32Array) Duplicate(ctx Context) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self PackedInt32Array) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self PackedInt32Array) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self PackedInt32Array) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt32Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedInt64Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedInt64Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the integer at the given index.
*/
//go:nosplit
func (self PackedInt64Array) Set(index Int, value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends a value to the array.
*/
//go:nosplit
func (self PackedInt64Array) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedInt64Array) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedInt64Array] at the end of this array.
*/
//go:nosplit
func (self PackedInt64Array) AppendArray(array PackedInt64Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedInt64Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedInt64Array) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedInt64Array) Fill(value Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedInt64Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedInt64Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self PackedInt64Array) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedInt64Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedInt64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedInt64Array) Slice(ctx Context, begin Int, end Int) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]int64_array.size() * 8[/code].
*/
//go:nosplit
func (self PackedInt64Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self PackedInt64Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self PackedInt64Array) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedInt64Array) Duplicate(ctx Context) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self PackedInt64Array) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self PackedInt64Array) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self PackedInt64Array) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedInt64Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedFloat32Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedFloat32Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the float at the given index.
*/
//go:nosplit
func (self PackedFloat32Array) Set(index Int, value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self PackedFloat32Array) PushBack(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedFloat32Array) Append(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedFloat32Array] at the end of this array.
*/
//go:nosplit
func (self PackedFloat32Array) AppendArray(array PackedFloat32Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedFloat32Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedFloat32Array) Insert(at_index Int, value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedFloat32Array) Fill(value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedFloat32Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedFloat32Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Has(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedFloat32Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedFloat32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedFloat32Array) Slice(ctx Context, begin Int, end Int) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]float32_array.size() * 4[/code].
*/
//go:nosplit
func (self PackedFloat32Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Bsearch(value Float, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedFloat32Array) Duplicate(ctx Context) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Find(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Rfind(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat32Array) Count(value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat32Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedFloat64Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedFloat64Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the float at the given index.
*/
//go:nosplit
func (self PackedFloat64Array) Set(index Int, value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self PackedFloat64Array) PushBack(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedFloat64Array) Append(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedFloat64Array] at the end of this array.
*/
//go:nosplit
func (self PackedFloat64Array) AppendArray(array PackedFloat64Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedFloat64Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedFloat64Array) Insert(at_index Int, value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedFloat64Array) Fill(value Float) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedFloat64Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedFloat64Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Has(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedFloat64Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedFloat64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedFloat64Array) Slice(ctx Context, begin Int, end Int) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]float64_array.size() * 8[/code].
*/
//go:nosplit
func (self PackedFloat64Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Bsearch(value Float, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedFloat64Array) Duplicate(ctx Context) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Find(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Rfind(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedFloat64Array) Count(value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedFloat64Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedStringArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedStringArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the [String] at the given index.
*/
//go:nosplit
func (self PackedStringArray) Set(index Int, value String) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends a string element at end of the array.
*/
//go:nosplit
func (self PackedStringArray) PushBack(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedStringArray) Append(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedStringArray] at the end of this array.
*/
//go:nosplit
func (self PackedStringArray) AppendArray(array PackedStringArray) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedStringArray) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedStringArray) Insert(at_index Int, value String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedStringArray) Fill(value String) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedStringArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedStringArray) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self PackedStringArray) Has(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedStringArray) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedStringArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedStringArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedStringArray) Slice(ctx Context, begin Int, end Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a [PackedByteArray] with each string encoded as bytes.
*/
//go:nosplit
func (self PackedStringArray) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self PackedStringArray) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self PackedStringArray) Bsearch(value String, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedStringArray) Duplicate(ctx Context) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self PackedStringArray) Find(value String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self PackedStringArray) Rfind(value String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self PackedStringArray) Count(value String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedStringArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedVector2Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedVector2Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the [Vector2] at the given index.
*/
//go:nosplit
func (self PackedVector2Array) Set(index Int, value Vector2) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Inserts a [Vector2] at the end.
*/
//go:nosplit
func (self PackedVector2Array) PushBack(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedVector2Array) Append(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedVector2Array] at the end of this array.
*/
//go:nosplit
func (self PackedVector2Array) AppendArray(array PackedVector2Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedVector2Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedVector2Array) Insert(at_index Int, value Vector2) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedVector2Array) Fill(value Vector2) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedVector2Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedVector2Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Has(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedVector2Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedVector2Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector2Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedVector2Array) Slice(ctx Context, begin Int, end Int) PackedVector2Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedVector2Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a [PackedByteArray] with each vector encoded as bytes.
*/
//go:nosplit
func (self PackedVector2Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Bsearch(value Vector2, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedVector2Array) Duplicate(ctx Context) PackedVector2Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedVector2Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Find(value Vector2, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Rfind(value Vector2, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector2Array) Count(value Vector2) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector2Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedVector3Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedVector3Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the [Vector3] at the given index.
*/
//go:nosplit
func (self PackedVector3Array) Set(index Int, value Vector3) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Inserts a [Vector3] at the end.
*/
//go:nosplit
func (self PackedVector3Array) PushBack(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedVector3Array) Append(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedVector3Array] at the end of this array.
*/
//go:nosplit
func (self PackedVector3Array) AppendArray(array PackedVector3Array) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedVector3Array) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedVector3Array) Insert(at_index Int, value Vector3) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedVector3Array) Fill(value Vector3) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedVector3Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedVector3Array) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Has(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedVector3Array) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedVector3Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector3Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedVector3Array) Slice(ctx Context, begin Int, end Int) PackedVector3Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedVector3Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a [PackedByteArray] with each vector encoded as bytes.
*/
//go:nosplit
func (self PackedVector3Array) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Bsearch(value Vector3, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedVector3Array) Duplicate(ctx Context) PackedVector3Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedVector3Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Find(value Vector3, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Rfind(value Vector3, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self PackedVector3Array) Count(value Vector3) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedVector3Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self PackedColorArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self PackedColorArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes the [Color] at the given index.
*/
//go:nosplit
func (self PackedColorArray) Set(index Int, value Color) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}

/*
Appends a value to the array.
*/
//go:nosplit
func (self PackedColorArray) PushBack(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self PackedColorArray) Append(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Appends a [PackedColorArray] at the end of this array.
*/
//go:nosplit
func (self PackedColorArray) AppendArray(array PackedColorArray) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Removes an element from the array by index.
*/
//go:nosplit
func (self PackedColorArray) RemoveAt(index Int) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self PackedColorArray) Insert(at_index Int, value Color) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self PackedColorArray) Fill(value Color) {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}

/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self PackedColorArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self PackedColorArray) Clear() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self PackedColorArray) Has(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self PackedColorArray) Reverse() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Returns the slice of the [PackedColorArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedColorArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self PackedColorArray) Slice(ctx Context, begin Int, end Int) PackedColorArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedColorArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns a [PackedByteArray] with each color encoded as bytes.
*/
//go:nosplit
func (self PackedColorArray) ToByteArray(ctx Context) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self PackedColorArray) Sort() {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}

/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self PackedColorArray) Bsearch(value Color, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self PackedColorArray) Duplicate(ctx Context) PackedColorArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedColorArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self PackedColorArray) Find(value Color, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self PackedColorArray) Rfind(value Color, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self PackedColorArray) Count(value Color) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(selfPtr).builtin.PackedColorArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

type ObjectConnectFlags int64

/*
Returns the object's built-in class name, as a [String]. See also [method is_class].
[b]Note:[/b] This method ignores [code]class_name[/code] declarations. If this object's script has defined a [code]class_name[/code], the base, built-in class name is returned instead.
*/
//go:nosplit
func (self Object) GetClass(ctx Context) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_class, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the object inherits from the given [param class]. See also [method get_class].
[codeblocks]
[gdscript]
var sprite2d = Sprite2D.new()
sprite2d.is_class("Sprite2D") # Returns true
sprite2d.is_class("Node")     # Returns true
sprite2d.is_class("Node3D")   # Returns false
[/gdscript]
[csharp]
var sprite2D = new Sprite2D();
sprite2D.IsClass("Sprite2D"); // Returns true
sprite2D.IsClass("Node");     // Returns true
sprite2D.IsClass("Node3D");   // Returns false
[/csharp]
[/codeblocks]
[b]Note:[/b] This method ignores [code]class_name[/code] declarations in the object's script.
*/
//go:nosplit
func (self Object) IsClass(class String) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(class))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_class, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Assigns [param value] to the given [param property]. If the property does not exist or the given [param value]'s type doesn't match, nothing happens.
[codeblocks]
[gdscript]
var node = Node2D.new()
node.set("global_scale", Vector2(8, 2.5))
print(node.global_scale) # Prints (8, 2.5)
[/gdscript]
[csharp]
var node = new Node2D();
node.Set(Node2D.PropertyName.GlobalScale, new Vector2(8, 2.5));
GD.Print(node.GlobalScale); // Prints Vector2(8, 2.5)
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Set(property StringName, value Variant) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns the [Variant] value of the given [param property]. If the [param property] does not exist, this method returns [code]null[/code].
[codeblocks]
[gdscript]
var node = Node2D.new()
node.rotation = 1.5
var a = node.get("rotation") # a is 1.5
[/gdscript]
[csharp]
var node = new Node2D();
node.Rotation = 1.5f;
var a = node.Get(Node2D.PropertyName.Rotation); // a is 1.5
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Get(ctx Context, property StringName) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Assigns a new [param value] to the property identified by the [param property_path]. The path should be a [NodePath] relative to this object, and can use the colon character ([code]:[/code]) to access nested properties.
[codeblocks]
[gdscript]
var node = Node2D.new()
node.set_indexed("position", Vector2(42, 0))
node.set_indexed("position:y", -10)
print(node.position) # Prints (42, -10)
[/gdscript]
[csharp]
var node = new Node2D();
node.SetIndexed("position", new Vector2(42, 0));
node.SetIndexed("position:y", -10);
GD.Print(node.Position); // Prints (42, -10)
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property_path] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) SetIndexed(property_path NodePath, value Variant) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property_path))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_indexed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Gets the object's property indexed by the given [param property_path]. The path should be a [NodePath] relative to the current object and can use the colon character ([code]:[/code]) to access nested properties.
[b]Examples:[/b] [code]"position:x"[/code] or [code]"material:next_pass:blend_mode"[/code].
[codeblocks]
[gdscript]
var node = Node2D.new()
node.position = Vector2(5, -10)
var a = node.get_indexed("position")   # a is Vector2(5, -10)
var b = node.get_indexed("position:y") # b is -10
[/gdscript]
[csharp]
var node = new Node2D();
node.Position = new Vector2(5, -10);
var a = node.GetIndexed("position");   // a is Vector2(5, -10)
var b = node.GetIndexed("position:y"); // b is -10
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property_path] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
[b]Note:[/b] This method does not support actual paths to nodes in the [SceneTree], only sub-property paths. In the context of nodes, use [method Node.get_node_and_resource] instead.
*/
//go:nosplit
func (self Object) GetIndexed(ctx Context, property_path NodePath) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property_path))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_indexed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the object's property list as an [Array] of dictionaries. Each [Dictionary] contains the following entries:
- [code]name[/code] is the property's name, as a [String];
- [code]class_name[/code] is an empty [StringName], unless the property is [constant TYPE_OBJECT] and it inherits from a class;
- [code]type[/code] is the property's type, as an [int] (see [enum Variant.Type]);
- [code]hint[/code] is [i]how[/i] the property is meant to be edited (see [enum PropertyHint]);
- [code]hint_string[/code] depends on the hint (see [enum PropertyHint]);
- [code]usage[/code] is a combination of [enum PropertyUsageFlags].
[b]Note:[/b] In GDScript, all class members are treated as properties. In C# and GDExtension, it may be necessary to explicitly mark class members as Godot properties using decorators or attributes.
*/
//go:nosplit
func (self Object) GetPropertyList() ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[ArrayOf[Dictionary]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_property_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns this object's methods and their signatures as an [Array] of dictionaries. Each [Dictionary] contains the following entries:
- [code]name[/code] is the name of the method, as a [String];
- [code]args[/code] is an [Array] of dictionaries representing the arguments;
- [code]default_args[/code] is the default arguments as an [Array] of variants;
- [code]flags[/code] is a combination of [enum MethodFlags];
- [code]id[/code] is the method's internal identifier [int];
- [code]return[/code] is the returned value, as a [Dictionary];
[b]Note:[/b] The dictionaries of [code]args[/code] and [code]return[/code] are formatted identically to the results of [method get_property_list], although not all entries are used.
*/
//go:nosplit
func (self Object) GetMethodList() ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[ArrayOf[Dictionary]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_method_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the given [param property] has a custom default value. Use [method property_get_revert] to get the [param property]'s default value.
[b]Note:[/b] This method is used by the Inspector dock to display a revert icon. The object must implement [method _property_can_revert] to customize the default value. If [method _property_can_revert] is not implemented, this method returns [code]false[/code].
*/
//go:nosplit
func (self Object) PropertyCanRevert(property StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_property_can_revert, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the custom default value of the given [param property]. Use [method property_can_revert] to check if the [param property] has a custom default value.
[b]Note:[/b] This method is used by the Inspector dock to display a revert icon. The object must implement [method _property_get_revert] to customize the default value. If [method _property_get_revert] is not implemented, this method returns [code]null[/code].
*/
//go:nosplit
func (self Object) PropertyGetRevert(ctx Context, property StringName) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_property_get_revert, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Sends the given [param what] notification to all classes inherited by the object, triggering calls to [method _notification], starting from the highest ancestor (the [Object] class) and going down to the object's script.
If [param reversed] is [code]true[/code], the call order is reversed.
[codeblocks]
[gdscript]
var player = Node2D.new()
player.set_script(load("res://player.gd"))

player.notification(NOTIFICATION_ENTER_TREE)
# The call order is Object -> Node -> Node2D -> player.gd.

player.notification(NOTIFICATION_ENTER_TREE, true)
# The call order is player.gd -> Node2D -> Node -> Object.
[/gdscript]
[csharp]
var player = new Node2D();
player.SetScript(GD.Load("res://player.gd"));

player.Notification(NotificationEnterTree);
// The call order is GodotObject -> Node -> Node2D -> player.gd.

player.Notification(NotificationEnterTree, true);
// The call order is player.gd -> Node2D -> Node -> GodotObject.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) Notification(what Int, reversed bool) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, what)
	callframe.Arg(frame, reversed)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_notification, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns a [String] representing the object. Defaults to [code]"<ClassName#RID>"[/code]. Override [method _to_string] to customize the string representation of the object.
*/
//go:nosplit
func (self Object) ToString(ctx Context) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_to_string, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns the object's unique instance ID. This ID can be saved in [EncodedObjectAsID], and can be used to retrieve this object instance with [method @GlobalScope.instance_from_id].
*/
//go:nosplit
func (self Object) GetInstanceId() Int {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_instance_id, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Attaches [param script] to the object, and instantiates it. As a result, the script's [method _init] is called. A [Script] is used to extend the object's functionality.
If a script already exists, its instance is detached, and its property values and state are lost. Built-in property values are still kept.
*/
//go:nosplit
func (self Object) SetScript(script Variant) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(script))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_script, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns the object's [Script] instance, or [code]null[/code] if no script is attached.
*/
//go:nosplit
func (self Object) GetScript(ctx Context) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_script, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Adds or changes the entry [param name] inside the object's metadata. The metadata [param value] can be any [Variant], although some types cannot be serialized correctly.
If [param value] is [code]null[/code], the entry is removed. This is the equivalent of using [method remove_meta]. See also [method has_meta] and [method get_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) SetMeta(name StringName, value Variant) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Removes the given entry [param name] from the object's metadata. See also [method has_meta], [method get_meta] and [method set_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) RemoveMeta(name StringName) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_remove_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns the object's metadata value for the given entry [param name]. If the entry does not exist, returns [param default]. If [param default] is [code]null[/code], an error is also generated.
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) GetMeta(ctx Context, name StringName, def Variant) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	callframe.Arg(frame, mmm.Get(def))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if a metadata entry is found with the given [param name]. See also [method get_meta], [method set_meta] and [method remove_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) HasMeta(name StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the object's metadata entry names as a [PackedStringArray].
*/
//go:nosplit
func (self Object) GetMetaList() ArrayOf[StringName] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[ArrayOf[StringName]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_meta_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a user-defined [param signal]. Optional arguments for the signal can be added as an [Array] of dictionaries, each defining a [code]name[/code] [String] and a [code]type[/code] [int] (see [enum Variant.Type]). See also [method has_user_signal].
[codeblocks]
[gdscript]
add_user_signal("hurt", [
    { "name": "damage", "type": TYPE_INT },
    { "name": "source", "type": TYPE_OBJECT }
])
[/gdscript]
[csharp]
AddUserSignal("Hurt", new Godot.Collections.Array()
{
    new Godot.Collections.Dictionary()
    {
        { "name", "damage" },
        { "type", (int)Variant.Type.Int }
    },
    new Godot.Collections.Dictionary()
    {
        { "name", "source" },
        { "type", (int)Variant.Type.Object }
    }
});
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) AddUserSignal(signal String, arguments Array) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_add_user_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns [code]true[/code] if the given user-defined [param signal] name exists. Only signals added with [method add_user_signal] are included.
*/
//go:nosplit
func (self Object) HasUserSignal(signal StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_user_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Emits the given [param signal] by name. The signal must exist, so it should be a built-in signal of this class or one of its inherited classes, or a user-defined signal (see [method add_user_signal]). This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
Returns [constant ERR_UNAVAILABLE] if [param signal] does not exist or the parameters are invalid.
[codeblocks]
[gdscript]
emit_signal("hit", "sword", 100)
emit_signal("game_over")
[/gdscript]
[csharp]
EmitSignal(SignalName.Hit, "sword", 100);
EmitSignal(SignalName.GameOver);
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param signal] must be in snake_case when referring to built-in Godot signals. Prefer using the names exposed in the [code]SignalName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) EmitSignal(signal StringName, args ...Variant) int64 {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[int64](frame)
	if len(args) > 0 {
		panic(`varargs not supported for class methods yet`)
	}
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_emit_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Calls the [param method] on the object and returns the result. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
[codeblocks]
[gdscript]
var node = Node3D.new()
node.call("rotate", Vector3(1.0, 0.0, 0.0), 1.571)
[/gdscript]
[csharp]
var node = new Node3D();
node.Call(Node3D.MethodName.Rotate, new Vector3(1f, 0f, 0f), 1.571f);
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Call(ctx Context, method StringName, args ...Variant) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	if len(args) > 0 {
		panic(`varargs not supported for class methods yet`)
	}
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_call, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Calls the [param method] on the object during idle time. Always returns null, [b]not[/b] the method's result.
Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
[codeblocks]
[gdscript]
var node = Node3D.new()
node.call_deferred("rotate", Vector3(1.0, 0.0, 0.0), 1.571)
[/gdscript]
[csharp]
var node = new Node3D();
node.CallDeferred(Node3D.MethodName.Rotate, new Vector3(1f, 0f, 0f), 1.571f);
[/csharp]
[/codeblocks]
See also [method Callable.call_deferred].
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
[b]Note:[/b] If you're looking to delay the function call by a frame, refer to the [signal SceneTree.process_frame] and [signal SceneTree.physics_frame] signals.
[codeblock]
var node = Node3D.new()
# Make a Callable and bind the arguments to the node's rotate() call.
var callable = node.rotate.bind(Vector3(1.0, 0.0, 0.0), 1.571)
# Connect the callable to the process_frame signal, so it gets called in the next process frame.
# CONNECT_ONE_SHOT makes sure it only gets called once instead of every frame.
get_tree().process_frame.connect(callable, CONNECT_ONE_SHOT)
[/codeblock]
*/
//go:nosplit
func (self Object) CallDeferred(ctx Context, method StringName, args ...Variant) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	for _, arg := range args {
		callframe.Arg(frame, arg)
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	if len(args) > 0 {
		panic(`varargs not supported for class methods yet`)
	}
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_call_deferred, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Assigns [param value] to the given [param property], at the end of the current frame. This is equivalent to calling [method set] through [method call_deferred].
[codeblocks]
[gdscript]
var node = Node2D.new()
add_child(node)

node.rotation = 1.5
node.set_deferred("rotation", 3.0)
print(node.rotation) # Prints 1.5

await get_tree().process_frame
print(node.rotation) # Prints 3.0
[/gdscript]
[csharp]
var node = new Node2D();
node.Rotation = 1.5f;
node.SetDeferred(Node2D.PropertyName.Rotation, 3f);
GD.Print(node.Rotation); // Prints 1.5

await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
GD.Print(node.Rotation); // Prints 3.0
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) SetDeferred(property StringName, value Variant) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_deferred, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Calls the [param method] on the object and returns the result. Unlike [method call], this method expects all parameters to be contained inside [param arg_array].
[codeblocks]
[gdscript]
var node = Node3D.new()
node.callv("rotate", [Vector3(1.0, 0.0, 0.0), 1.571])
[/gdscript]
[csharp]
var node = new Node3D();
node.Callv(Node3D.MethodName.Rotate, new Godot.Collections.Array { new Vector3(1f, 0f, 0f), 1.571f });
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Callv(ctx Context, method StringName, arg_array Array) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	callframe.Arg(frame, mmm.Get(arg_array))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_callv, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the given [param method] name exists in the object.
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) HasMethod(method StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_method, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the given [param signal] name exists in the object.
[b]Note:[/b] In C#, [param signal] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]SignalName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) HasSignal(signal StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the list of existing signals as an [Array] of dictionaries.
[b]Note:[/b] Due of the implementation, each [Dictionary] is formatted very similarly to the returned values of [method get_method_list].
*/
//go:nosplit
func (self Object) GetSignalList() ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[ArrayOf[Dictionary]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_signal_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an [Array] of connections for the given [param signal] name. Each connection is represented as a [Dictionary] that contains three entries:
- [code skip-lint]signal[/code] is a reference to the [Signal];
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum ConnectFlags].
*/
//go:nosplit
func (self Object) GetSignalConnectionList(signal StringName) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[ArrayOf[Dictionary]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_signal_connection_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an [Array] of signal connections received by this object. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to the [Signal];
- [code]callable[/code] is a reference to the [Callable];
- [code]flags[/code] is a combination of [enum ConnectFlags].
*/
//go:nosplit
func (self Object) GetIncomingConnections() ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[ArrayOf[Dictionary]](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_incoming_connections, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Connects a [param signal] by name to a [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum ConnectFlags] constants).
A signal can only be connected once to the same [Callable]. If the signal is already connected, this method returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
If the [param callable]'s object is freed, the connection will be lost.
[b]Examples with recommended syntax:[/b]
Connecting signals is one of the most common operations in Godot and the API gives many options to do so, which are described further down. The code block below shows the recommended approach.
[codeblocks]
[gdscript]
func _ready():
    var button = Button.new()
    # `button_down` here is a Signal variant type, and we thus call the Signal.connect() method, not Object.connect().
    # See discussion below for a more in-depth overview of the API.
    button.button_down.connect(_on_button_down)

    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # We use Signal.connect() again, and we also use the Callable.bind() method,
    # which returns a new Callable with the parameter binds.
    player.hit.connect(_on_player_hit.bind("sword", 100))

func _on_button_down():
    print("Button down!")

func _on_player_hit(weapon_type, damage):
    print("Hit with weapon %s for %d damage." % [weapon_type, damage])
[/gdscript]
[csharp]
public override void _Ready()
{
    var button = new Button();
    // C# supports passing signals as events, so we can use this idiomatic construct:
    button.ButtonDown += OnButtonDown;

    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // We can use lambdas when we need to bind additional parameters.
    player.Hit += () => OnPlayerHit("sword", 100);
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}

private void OnPlayerHit(string weaponType, int damage)
{
    GD.Print($"Hit with weapon {weaponType} for {damage} damage.");
}
[/csharp]
[/codeblocks]
[b][code skip-lint]Object.connect()[/code] or [code skip-lint]Signal.connect()[/code]?[/b]
As seen above, the recommended method to connect signals is not [method Object.connect]. The code block below shows the four options for connecting signals, using either this legacy method or the recommended [method Signal.connect], and using either an implicit [Callable] or a manually defined one.
[codeblocks]
[gdscript]
func _ready():
    var button = Button.new()
    # Option 1: Object.connect() with an implicit Callable for the defined function.
    button.connect("button_down", _on_button_down)
    # Option 2: Object.connect() with a constructed Callable using a target object and method name.
    button.connect("button_down", Callable(self, "_on_button_down"))
    # Option 3: Signal.connect() with an implicit Callable for the defined function.
    button.button_down.connect(_on_button_down)
    # Option 4: Signal.connect() with a constructed Callable using a target object and method name.
    button.button_down.connect(Callable(self, "_on_button_down"))

func _on_button_down():
    print("Button down!")
[/gdscript]
[csharp]
public override void _Ready()
{
    var button = new Button();
    // Option 1: In C#, we can use signals as events and connect with this idiomatic syntax:
    button.ButtonDown += OnButtonDown;
    // Option 2: GodotObject.Connect() with a constructed Callable from a method group.
    button.Connect(Button.SignalName.ButtonDown, Callable.From(OnButtonDown));
    // Option 3: GodotObject.Connect() with a constructed Callable using a target object and method name.
    button.Connect(Button.SignalName.ButtonDown, new Callable(this, MethodName.OnButtonDown));
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}
[/csharp]
[/codeblocks]
While all options have the same outcome ([code]button[/code]'s [signal BaseButton.button_down] signal will be connected to [code]_on_button_down[/code]), [b]option 3[/b] offers the best validation: it will print a compile-time error if either the [code]button_down[/code] [Signal] or the [code]_on_button_down[/code] [Callable] are not defined. On the other hand, [b]option 2[/b] only relies on string names and will only be able to validate either names at runtime: it will print a runtime error if [code]"button_down"[/code] doesn't correspond to a signal, or if [code]"_on_button_down"[/code] is not a registered method in the object [code]self[/code]. The main reason for using options 1, 2, or 4 would be if you actually need to use strings (e.g. to connect signals programmatically based on strings read from a configuration file). Otherwise, option 3 is the recommended (and fastest) method.
[b]Binding and passing parameters:[/b]
The syntax to bind parameters is through [method Callable.bind], which returns a copy of the [Callable] with its parameters bound.
When calling [method emit_signal], the signal parameters can be also passed. The examples below show the relationship between these signal parameters and bound parameters.
[codeblocks]
[gdscript]
func _ready():
    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # Using Callable.bind().
    player.hit.connect(_on_player_hit.bind("sword", 100))

    # Parameters added when emitting the signal are passed first.
    player.emit_signal("hit", "Dark lord", 5)

# We pass two arguments when emitting (`hit_by`, `level`),
# and bind two more arguments when connecting (`weapon_type`, `damage`).
func _on_player_hit(hit_by, level, weapon_type, damage):
    print("Hit by %s (level %d) with weapon %s for %d damage." % [hit_by, level, weapon_type, damage])
[/gdscript]
[csharp]
public override void _Ready()
{
    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // Using lambda expressions that create a closure that captures the additional parameters.
    // The lambda only receives the parameters defined by the signal's delegate.
    player.Hit += (hitBy, level) => OnPlayerHit(hitBy, level, "sword", 100);

    // Parameters added when emitting the signal are passed first.
    player.EmitSignal(SignalName.Hit, "Dark lord", 5);
}

// We pass two arguments when emitting (`hit_by`, `level`),
// and bind two more arguments when connecting (`weapon_type`, `damage`).
private void OnPlayerHit(string hitBy, int level, string weaponType, int damage)
{
    GD.Print($"Hit by {hitBy} (level {level}) with weapon {weaponType} for {damage} damage.");
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) Connect(signal StringName, callable Callable, flags Int) int64 {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_connect, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Disconnects a [param signal] by name from a given [param callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists.
*/
//go:nosplit
func (self Object) Disconnect(signal StringName, callable Callable) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_disconnect, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns [code]true[/code] if a connection exists between the given [param signal] name and [param callable].
[b]Note:[/b] In C#, [param signal] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]SignalName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) IsConnected(signal StringName, callable Callable) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_connected, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If set to [code]true[/code], the object becomes unable to emit signals. As such, [method emit_signal] and signal connections will not work, until it is set to [code]false[/code].
*/
//go:nosplit
func (self Object) SetBlockSignals(enable bool) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_block_signals, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns [code]true[/code] if the object is blocking its signals from being emitted. See [method set_block_signals].
*/
//go:nosplit
func (self Object) IsBlockingSignals() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_blocking_signals, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Emits the [signal property_list_changed] signal. This is mainly used to refresh the editor, so that the Inspector and editor plugins are properly updated.
*/
//go:nosplit
func (self Object) NotifyPropertyListChanged() {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_notify_property_list_changed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
If set to [code]true[/code], allows the object to translate messages with [method tr] and [method tr_n]. Enabled by default. See also [method can_translate_messages].
*/
//go:nosplit
func (self Object) SetMessageTranslation(enable bool) {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_message_translation, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}

/*
Returns [code]true[/code] if the object is allowed to translate messages with [method tr] and [method tr_n]. See also [method set_message_translation].
*/
//go:nosplit
func (self Object) CanTranslateMessages() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_can_translate_messages, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Translates a [param message], using the translation catalogs configured in the Project Settings. Further [param context] can be specified to help with the translation.
If [method can_translate_messages] is [code]false[/code], or no translation is available, this method returns the [param message] without changes. See [method set_message_translation].
For detailed examples, see [url=$DOCS_URL/tutorials/i18n/internationalizing_games.html]Internationalizing games[/url].
*/
//go:nosplit
func (self Object) Tr(ctx Context, message StringName, context StringName) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(message))
	callframe.Arg(frame, mmm.Get(context))
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_tr, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Translates a [param message] or [param plural_message], using the translation catalogs configured in the Project Settings. Further [param context] can be specified to help with the translation.
If [method can_translate_messages] is [code]false[/code], or no translation is available, this method returns [param message] or [param plural_message], without changes. See [method set_message_translation].
The [param n] is the number, or amount, of the message's subject. It is used by the translation system to fetch the correct plural form for the current language.
For detailed examples, see [url=$DOCS_URL/tutorials/i18n/localization_using_gettext.html]Localization using gettext[/url].
[b]Note:[/b] Negative and [float] numbers may not properly apply to some countable subjects. It's recommended handling these cases with [method tr].
*/
//go:nosplit
func (self Object) TrN(ctx Context, message StringName, plural_message StringName, n Int, context StringName) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(message))
	callframe.Arg(frame, mmm.Get(plural_message))
	callframe.Arg(frame, n)
	callframe.Arg(frame, mmm.Get(context))
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_tr_n, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if the [method Node.queue_free] method was called for the object.
*/
//go:nosplit
func (self Object) IsQueuedForDeletion() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_queued_for_deletion, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If this method is called during [constant NOTIFICATION_PREDELETE], this object will reject being freed and will remain allocated. This is mostly an internal function used for error handling to avoid the user from freeing objects when they are not intended to.
*/
//go:nosplit
func (self Object) CancelFree() {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_cancel_free, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
func (self Object) Virtual(name string) reflect.Value {
	switch name {
	default:
		return reflect.Value{}
	}
}

type RefCounted struct {
	_   [0]*RefCounted
	ptr Pointer
}

//go:nosplit
func (self RefCounted) AsPointer() Pointer { return self.ptr }

//go:nosplit
func (self *RefCounted) SetPointer(ptr Pointer) { self.ptr = ptr }

//go:nosplit
func (self RefCounted) Super() Object { return *(*Object)(unsafe.Pointer(&self)) }

//go:nosplit
func (self RefCounted) AsObject() Object { return *(*Object)(unsafe.Pointer(&self)) }

/*
Initializes the internal reference counter. Use this only if you really know what you are doing.
Returns whether the initialization was successful.
*/
//go:nosplit
func (self RefCounted) InitRef() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_init_ref, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Increments the internal reference counter. Use this only if you really know what you are doing.
Returns [code]true[/code] if the increment was successful, [code]false[/code] otherwise.
*/
//go:nosplit
func (self RefCounted) Reference() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_reference, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Decrements the internal reference counter. Use this only if you really know what you are doing.
Returns [code]true[/code] if the object should be freed after the decrement, [code]false[/code] otherwise.
*/
//go:nosplit
func (self RefCounted) Unreference() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_unreference, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the current reference count.
*/
//go:nosplit
func (self RefCounted) GetReferenceCount() Int {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_get_reference_count, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
func (self RefCounted) Virtual(name string) reflect.Value {
	switch name {
	default:
		return VirtualByName(self.Super(), name)
	}
}
